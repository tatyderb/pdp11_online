# Оглавление
# Введение
Цель проекта - написать эмулятор компьютера с простой архитектурой и реализовать IDE для написания и отладки программ на этом эмуляторе.
Для эмуляции выбран компьютер с простой архитектурой и одной из самых красивых систем команд, которые позволяли делать читаемым даже полученный байт-код.
Проект разделен на три части: эмулятор выполнения байт-кода, компилятор из ассемблера в байт-код и GUI для написания и отладки программ на ассемблере.
Для проверки корректности реализации архитектуры и набора команд дан эталонный эмулятор и набор интеграционных тестов.
# Краткий теоретический материал
## Что такое эмулятор и зачем он нужен
Эмулятор - это программа, которая создает для другой программы иллюзию, что она работает в привычной среде: получает данные в нужном формате, исполняет команды на правильной архитектуре и т. д. Задача эмулятора компьютера - обеспечить совместимость. Он занимается преобразованием команд и данных, чтобы всё работало как на исходном "железе".

Представим, что мы разрабатываем новое "железо". Это может быть новый мобильный телефон или медицинское оборудование. Для того, чтобы оно работало, нужно написать программы. Но программировать на инженерных образцах программистам очень дорого, ибо стоимость инженерных образцов ("железа" в разработке) на несколько порядков превышает стоимость серийных изделий. Для этого пишут эмулятор разрабатываемого "железа" и прикладные программы пишут на этом эмуляторе.

Другой вариант - работающие прикладные программы на устаревшем "железе". Для обслуживания сталелитейного цеха написаны программы. Само оборудование будет работать долго, но его компьютерная часть устарела. Такое уже не производят. Тогда покупают новый компьютер и для него пишут эмулятор старого компьютера и запускают программы на этом эмуляторе.

Почему проще написать эмулятор, чем переписывать прикладные программы?

* Для написания программы управления оборудованием (сталелитейный цех, станки, конвейер) нужны знания не только программистов, но и инженеров прикладных специальностей например, металлургов. То есть придется заново собирать знания прикладных специалистов о том, как должно работать оборудование. Гораздо проще взять описание старого компьютера. Там уже написано как он должен работать.
* Цена ошибки в программе управления оборудованием очень велика. Отлаживать программу в работающем цеху грозит аварией в случае ошибки. Если мы ошибемся при написании эмулятора старого компьютера, мы просто перезапустим эмулятор, найдем ошибку и исправим её.
## Архитектура компьютера
Будем эмулировать компьютер PDP-11.
* 1 байт = 8 бит
* 1 машинное слово = 2 байта = 16 бит
* Адресация little endian (в слове байт с меньшими разрядами лежит по меньшему адресу)
* RAM 64 Кб, слова и байты имеют единое адресное пространство со сквозной адресацией слов (т.е. слова имеют адреса 0, 2, 4, 6 и тд., байты в них имеют адреса 0, 1, 2, 3, 4, 5, 6, 7 и тд.)
* Последние 8 Кб RAM - так называемые "регистры внешних устройств", т.е. ячейки памяти, отвечающие за взаимодействие с внешними устройствами.
* 8 регистров общего назначения, состоят из 16 битных слов, нумерация от R0 до R7. Обращения к части регистра нет.
	* Регистр R6 (обозначается как SP) является так же указателем стека, stack pointer).
	* Регистр R7 (обозначается как PC) является так же счетчиком команд (program counter)
## Простейшая программа сложения двух чисел
Разберем простейшую программу, которая записывает число 2 в регистр R0, число 3 в регистр R1, далее складывает содержимое регистров R0 и R1 и записывает результат в R1.
```cpp
. = 1000        ; начинаем с адреса 1000
mov 	#2, R0  ; R0 = 2
mov 	#3, R1  ; R1 = 3
add		R0, R1  ; R1 = R0 + R1
halt            ; конец программы
```
Псевдокоманду ассемблера `.=1000` мы разберем позже.
С `;` до конца строки идут комментарии к программе.
Язык ассемблера регистронезависимый, то есть можно писать команды и названия регистров как большими, так и маленькими буквами.
## Структура команд
### Список команд
В проекте будет реализовано следующее подмножество команд, приведенное в таблице. Под таблицей - описание сокращений и условных обозначений.
**Все числа восьмеричные**.

| Мнемоника | Opcode | NZVC   | Описание                   | Комментарии   |
| --------- | ------ | ------ | -------------------------- | ------------- |
| ADCb d    | B055DD | `****` | Add Carry                  | d=d+C         |
| ADD  s,d  | 06SSDD | `****` | Add                        | d=s+d         |
| ASH  s,r  | 072RSS | `****` | Arithmetic Shift           | r=r*2^s(EIS)# |
| ASHC s,r  | 073RSS | `****` | Arithmetic Shift Combined  | (EIS)#        |
| ASLb d    | B063DD | `****` | Arithmetic Shift Left      | d=d*2         |
| ASRb d    | B062DD | `****` | Arithmetic Shift Right     | d=d/2         |
| BCC  a    | 1030XX | `----` | Branch if Carry Clear      | If C=0        |
| BCS  a    | 1034XX | `----` | Branch if Carry Set        | If C=1        |
| BEQ  a    | 0014XX | `----` | Branch if Equal            | If Z=1        |
| BGE  a    | 0020XX | `----` | Branch if Greater or Equal | If NxV=0      |
| BGT  a    | 0030XX | `----` | Branch if Greater Than     | If Zv{NxV}=0  |
| BICb s,d  | B4SSDD | `**0-` | Bit Clear                  | d=d&{~s}      |
| BISb s,d  | B5SSDD | `**0-` | Bit Set (OR)               | d=dvs         |
| BITb s,d  | B3SSDD | `**0-` | Bit Test (AND)             | d&s           |
| BHI  a    | 1010XX | `----` | Branch if Higher           | If CvZ=0      |
| BHIS a    | 1030XX | `----` | Branch if Higher or Same   | If C=0        |
| BLE  a    | 0034XX | `----` | Branch if Less or Equal    | If Zv{NxV}=1  |
| BLT  a    | 0024XX | `----` | Branch if Less Than        | If NxV=1      |
| BLO  a    | 1034XX | `----` | Branch if Lower            | If C=1        |
| BLOS a    | 1014XX | `----` | Branch if Lower or Same    | If CvZ=1      |
| BMI  a    | 1004XX | `----` | Branch if Minus            | If N=1        |
| BNE  a    | 0010XX | `----` | Branch if Not Equal        | If Z=0        |
| BPL  a    | 1000XX | `----` | Branch if Plus             | If N=0        |
| BR   a    | 0004XX | `----` | Branch                     | PC=PC+2*XX    |
| BVC  a    | 1020XX | `----` | Branch if Overflow Clear   | If V=0        |
| BVS  a    | 1024XX | `----` | Branch if Overflow Set     | If V=1        |
| CALL d    | 0047DD | `----` | Call subroutine            | (= JSR PC,d)  |
| CCC       | 000257 | `0000` | Clear all Condition Codes  | {C,N,V,Z}=0   |
| CLC       | 000241 | `---0` | Clear Carry                | C=0           |
| CLN       | 000250 | `0---` | Clear Negative             | N=0           |
| CLRb d    | B050DD | `0100` | Clear                      | d=0           |
| CLV       | 000242 | `--0-` | Clear Overflow             | V=0           |
| CLZ       | 000244 | `-0--` | Clear Zero                 | Z=0           |
| CMPb s,d  | B2SSDD | `****` | Compare                    | s-d           |
| COMb d    | B051DD | `**01` | Complement                 | d=~d          |
| DECb d    | B053DD | `***-` | Decrement                  | d=d-1         |
| HALT      | 000000 | `----` | Halt                       |               |
| INCb d    | B052DD | `***-` | Increment                  | d=d+1         |
| JMP  d    | 0001DD | `----` | Jump                       | PC=d          |
| JSR  r,d  | 004RDD | `----` | Jump to Subroutine         | r=PC,PC=d     |
| MOVb s,d  | B1SSDD | `**0-` | Move                       | d=s           |
| NEGb d    | B054DD | `****` | Negate                     | d=-d          |
| NOP       | 000240 | `----` | No Operation               |               |
| RESET     | 000005 | `----` | Reset external bus         |               |
| RETURN    | 000207 | `----` | Return from subroutine     | (= RTS PC)    |
| ROLb d    | B061DD | `****` | Rotate Left                | d={C,d}<-     |
| RORb d    | B060DD | `****` | Rotate Right               | d=->{C,d}     |
| RTS  r    | 00020R | `----` | Return from Subroutine     | PC=r,r=(SP)+  |
| SBCb d    | B056DD | `****` | Subtract Carry             | d=d-C         |
| SCC       | 000277 | `1111` | Set all Condition Codes    | {C,N,V,Z}=1   |
| SEC       | 000261 | `---1` | Set Carry                  | C=1           |
| SEN       | 000270 | `1---` | Set Negative               | N=1           |
| SEV       | 000262 | `--1-` | Set Overflow               | V=1           |
| SEZ       | 000264 | `-1--` | Set Zero                   | Z=1           |
| SOB  r,a  | 077RNN | `----` | Subtract One and Branch    | PC=PC-2*NN  # |
| SUB  s,d  | 16SSDD | `****` | Subtract                   | d=d-s         |
| SWAB d    | 0003DD | `**00` | Swap Bytes                 |               |
| SXT  d    | 0067DD | `-*0-` | Sign Extend                | d=0 or -1   # |
| TSTb d    | B057DD | `**00` | Test                       | d             |
| XOR  r,d  | 074RDD | `**0-` | Exclusive OR               | d=dxr       # |

### Условные обозначения колонки opcode

| Обозначение | Что значит |
|----|----|
| B	| 0 for word, 1 for byte (1 bit) |
| DD |	Destination field (6 bits) |
| N		| Number (3 bits)	|
| NN	|	Number (6 bits)	|
| R	|	Register (3 bits, R0-5/SP/PC)	|
| SS	|	Source field (6 bits)	|
| TT	|	Number (8 bits)	|
| XX	|	Offset (8 bits, -128 to +127)	|

### Обозначения в мнемониках и комментариях

| Обозначение | Что значит                               |
| ----------- | ---------------------------------------- |
| Rn          | General purpose Register (16-bit, n=0-5) |
| SP          | Stack Pointer (16-bit, R6)               |
| PC          | Program Counter (16-bit, R7)             |
| PS          | Processor Status (16-bit)                |

| Описания            | Что значит                              |
| ------------------- | --------------------------------------- |
| a                   | Relative address                        |
| b                   | Blank or B for word or byte operand(s)  |
| d s                 | Destination/source                      |
| n                   | Register number (0 to 5)                |
| nn                  | 16-bit expression (0 to 65535)          |
| r                   | Register (Rn,SP,PC)                     |
| t                   | Trap number (0 to 255)                  |
| `+` `-` `*` `/` `^` | Add/subtract/multiply/divide/power      |
| `&` `~` `v` `x`     | Logical AND/NOT, inclusive/exclusive OR |
| `<-` `->`           | Rotate left/right                       |
| `{ }` `< : >`       | Combination of operands/bit range       |
| `#`                 | Not applicable to all PDP-11s           |
## Описание структуры команд
Команды записываются в одном машинном слове (16 бит) и состоят из кода операции (operation code, opcode) и аргументов. Аргументов может быть 0, 1 или 2.
* команда `HALT`, код операции `000000` длиной 16 бит, аргументов нет.
* команда `INC`, код операции `0052` длиной 10 бит, один аргумент типа DD.
* команда `BR`, код операции `0004` длиной 8 бит, один аргумент типа ХХ.
* команда `MOV`, код операции `01` длиной 4 бит, два аргумента, типа SS и DD.
Часть команд существует в двух вариантах - для работы с байтами (байтовая) и для работы со словами (не байтовая), в мнемониках байтовый вариант команды имеет букву `B` в название команды и код операции начинается с бита 1.
* команда `MOV`, код операции `01` (бинарный `0001`)
* команда `MOVB`, код операции `11` (бинарный `1001`)
## Структура команд с аргументами типа SS и DD
Рассмотрим как пользоваться таблицей команд. 

| Мнемоника | Opcode     | NZVC   | Описание  | Комментарии |
| --------- | ---------- | ------ | --------- | ----------- |
| HALT      | *000000*   | `----` | Halt      |             |
| ADD s, d  | **06**SSDD | `****` | Add       | d = s + d   |
| MOVb s,d  | B1SSDD     | `**0-` | Move      | d=s         |
| INCb d    | B052DD     | `***-` | Increment | d=d+1       |
В таблице указаны:
* Мнемоники команды, указаны её аргументы
    * можно писать как маленькими, так и большими буквами и команды, и аргументы.
    * `s` (source) - источник, откуда читаем; `d` (destination) - цель, куда пишем результат команды.
* Opcode (код операции), как в слове зашифрованы код команды и ее аргументы.
* NZVC - флаги состояния процессора. О них поговорим позже, пока игнорируем этот столбец.
* Описание команды.
* Комментарии по работе команды.

### Как описаны коды операций в столбце Opcode, команда ADD

Разберем как зашифрованы команды в таблице. Посмотрим в условные обозначения. 
В коде операции
* SS и DD - аргументы длиной каждый по 6 бит
* B - 0 или 1, 1 бит
Команда `ADD` описана как **06**SSDD, про SS и DD мы знаем пока только то, что длина каждого аргумента 6 бит. Все слово 16 бит. То есть на код операции осталось 16 - 6 - 6 = 4 бита. Эти 4 старших бита закодированы **восьмеричными** цифрами 06 или бинарными 0110. 

16 бит слова с командой ADD, биты отвечающие за аргументы обозначены как `s` и `d`.

```
|15            8|7             0| - номера бит
|0|1|1|0|s|s|s|s|s|s|d|d|d|d|d|d| - содержимое бит, бинарные числа
|0|  6  |  S  |  S  |  D  |  D  | - содержимое бит, восьмеричные числа
```

### Команда MOV

| Мнемоника | Opcode | NZVC | Описание | Комментарии |
|-----|----|----|----|----|
| MOVb s,d    | B1SSDD   | `**0-`   | Move                         | d=s          | 

В записи мнемоники `MOVb s,d` означает, что у нас две разных команды. `MOV` и `MOVB` (вариант команды, который работает не со словами, а с байтами, о нем подробнее разберем позже). 

У них разные коды операций, `B` в коде операций означает 0 для команды `MOV` и 1 для команды `MOVB`. То есть выше краткая запись для двух разных команд. Развернуто: 

| Мнемоника | Opcode | NZVC | Описание | Комментарии |
|-----|----|----|----|----|
| MOV s,d    | **01**SSDD   | `**0-`   | Move                         | d=s          | 
| MOVB s,d    | **11**SSDD   | `**0-`   | Move (byte)                         | d=s          | 

`MOV` - самая частая команда ассемблера. Её код `01` (первая команда ассемблера).

Проще, чем `MOV`, запомнить только код операции `HALT` - нули во всех битах. 0 - стоп.

16 бит слова с командой `MOV`, биты отвечающие за аргументы обозначены как `s` и `d`.

```
|15            8|7             0| - номера бит
|0|0|0|1|s|s|s|s|s|s|d|d|d|d|d|d| - содержимое бит, бинарные числа
|0|  1  |  S  |  S  |  D  |  D  | - содержимое бит, восьмеричные числа
```

### Команда INC (increment)

Разберем как кодируется команда увеличения (increment) числа на 1. Её нет в первом тесте, но вы должны понимать, что не у всех команд будет обязательно два аргумента.

| Мнемоника | Opcode | NZVC | Описание | Комментарии |
|-----|----|----|----|----|
| INCb d      | B052DD   | `***-`   | Increment                    | d=d+1        | 

Как и в `MOVb` тут зашифровано две команды, `INC` (увеличить значение *слова* на 1) и `INCB` (увеличит значение *байта* на 1). В языке Си вы знаете эту команду как `++` (автоинкремент).

| Мнемоника | Opcode | NZVC | Описание | Комментарии |
|-----|----|----|----|----|
| INC d      | **0052**DD   | `***-`   | Increment                    | d=d+1        | 
| INCB d      | **1052**DD   | `***-`   | Increment                    | d=d+1        | 

В команде только один аргумент DD. 16 бит слова с командой `INC`, биты отвечающие за аргумент обозначены как `d`.

```
|15            8|7             0| - номера бит
|0|0|0|0|1|0|1|0|1|0|d|d|d|d|d|d| - содержимое бит, бинарные числа
|0|  0  |  5  |  2  |  D  |  D  | - содержимое бит, восьмеричные числа
```

## ## Аргументы команды

Вспомним нашу программу.

```cpp
. = 1000        ; начинаем с адреса 1000
mov 	#2, R0  ; R0 = 2
mov 	#3, R1  ; R1 = 3
add		R0, R1  ; R1 = R0 + R1
halt            ; конец программы
```
У команды `halt` аргументов нет.

В команде `mov` аргументы определяют **что** (число 2) **куда** (в регистр R0) записывать. То есть от первого аргумента нужно значение, а от второго - адрес, по которому записываем результат.

В команде `add` от первого аргумента нужен результат. Мы смотрим **что** нужно прибавить ко второму аргументу. Но от второго аргумента нужно и значение (**что** мы складываем, число 3), и адрес (**куда** мы записываем результат, в R1).

То есть для аргумента нас интересует как значение, так и адрес, на который указывает аргумент. При этом адресовать нужно различные участки памяти.

Например, команда `mov` копирует данные. Копировать данные нужно:

* из регистра в регистр,
* из регистра в общую память RAM,
* из RAM в регистр,
* из RAM в RAM (по разным адресам),
* посылать данные и читать данные из внешних устройств (монитор, клавиатура).

Можно определить для каждого типа копирования свою команду (в языке Си определена функция `scanf` для считывания данных из входного потока и `printf` для вывода данных в выходной поток).

Можно определить аргументы так, чтобы описывать все взаимодействия в регистрах и памяти.

### Аргументы SS и DD
 
Регистр - основа определения аргумента. Регистров 8, чтобы закодировать номер регистра от 0 до 7 нужно 3 бита (3 бинарных цифры, от 000 до 111).

Аргументы SS и DD длиной 6 бит, последние 3 бита - номер регистра, первые 3 бита определяют как мы этот номер регистра трактуем, то есть режим (или мода) адресации. 3 бита на режим адресации, то есть этих режимов может быть 8 штук, от моды 0, до моды 7. 

![mr.png](https://stepik.org/media/attachments/lesson/325592/mr.png)

Рассмотрим команду `INC`, которое увеличивает значение аргумента на 1. Аналог - команда языка Си `++` или `+= 1`.

| Мнемоника | Opcode | NZVC | Описание | Комментарии |
|-----|----|----|----|----|
| INC d      | **0052**DD   | `***-`   | Increment                    | d=d+1        | 

В команде только один аргумент DD. 16 бит слова с командой `INC`, биты отвечающие за аргумент обозначены как `d`.

```
|15            8|7             0| - номера бит
|0|0|0|0|1|0|1|0|1|0|d|d|d|d|d|d| - содержимое бит, бинарные числа
|0|  0  |  5  |  2  |  D  |  D  | - содержимое бит, восьмеричные числа
```
то есть
```
|15            8|7             0| - номера бит
|0|0|0|0|1|0|1|0|1|0|m|m|m|r|r|r| - 3 бита на моду, 3 бита на регистр
```

Аналогично для аргумента SS, первые 3 бита кодируют моду, следующие 3 бита - номер регистра.

Команда `MOV`:

```
|15            8|7             0| - номера бит
|0|0|0|1|m|m|m|r|r|r|m|m|m|r|r|r| - содержимое бит, бинарные числа
|0|  1  |  S  |  S  |  D  |  D  | - содержимое бит, восьмеричные числа
```

## Моды адресации в аргументах SS и DD
### Таблица обозначений мод адресаций

| Мода | Обозначение | Пример | Описание |
|----|----|-----|----------|
| 0 | `R3` | `inc R3` | Значение в регистре `R3` |
| 1 | `(R3)` | `inc (R3)` | Адрес в регистре `R3` |
| 2 | `(R3)+` | `inc (R3)+` | Адрес в регистре `R3`, `R3+=2` |
| 3 | `@(R3)+` | `inc @(R3)+` | Адрес в регистре `R3` содержит адрес, `R3+=2` |
| 4 | `-(R3)` | `inc -(R3)` | `R3-=2`, Адрес в регистре `R3`  |
| 5 | `@-(R3)` | `inc -(R3)` | `R3-=2`, Адрес в регистре `R3` содержит адрес |
| 6 | `2(R3)` | `inc 2(R3)` | Сложить 2 и `R3`, это адрес |
| 7 | `@2(R3)` | `inc @2(R3)` | Сложить 2 и `R3`, по этому адресу лежит адрес |

При работе по 7 регистру, обозначения в коде ассемблера другие:

| Мода | Обозначение | Пример | Описание |
|----|----|-----|----------|
| 2 | `#3` | `mov #3, R0` | Константа 3 |
| 3 | `@#100` | `mov @#100, R0` | Значение по адресу 100 |
| 6 | `100` | `mov 100, R0` | Значение по адресу 100 |
| 7 | `@100` | `mov @100, R0` | По адресу 100 лежит адрес, по этому адресу лежит значение |
### ## Rn, мода 0, регистровый режим адресации

`Rn` - **значение находится в указанном регистре** с номером `n`.

Пример использования:
```cpp
INC R3      ; увеличить значение регистра R3 на 1
ADD R0, R1  ; в регистр R1 записать сумму чисел, лежащих в R0 и R1
``` 
Введем условные обозначения. **Rn** - регистр с номером `n`.

Для понимания работы мод адресации будем записывать их действие в псевдокоде, где `reg` - это "массив" регистров, а `mem` - это "массив" RAM. *Псевдокод я ввожу для короткой записи, разъясняющей, как работает режим адресации. Это не тот массив `mem`, что у нас в эмуляторе, доступ к памяти эмулятора мы делаем только через функции `w_read`, `w_write`, `b_read`, `b_write`.*

```cpp
adr = n         // куда (адрес)
val = reg[n]    // что (значение)
```
Если в `R3` уже лежало число 5, то `INC R3` изменит значение, в регистре `R3` теперь лежит число 6.

![mode0.png](https://stepik.org/media/attachments/lesson/325592/mode0.png)

#### Пример кодирования мнемоники

```cpp
add R0, R1
```
команда кодируется как
```
|15            8|7             0| - номера бит
|0|1|1|0|m|m|m|r|r|r|m|m|m|r|r|r| - содержимое бит, бинарные числа
|0|  6  |  S  |  S  |  D  |  D  | - содержимое бит, восьмеричные числа
```
Запишем моду 0 и регистры 0 и 1 для аргументов:
```
|15            8|7             0| - номера бит
|0|1|1|0|m|m|m|r|r|r|m|m|m|r|r|r| - содержимое бит, бинарные числа
|0|1|1|0|0|0|0|0|0|0|0|0|0|1|1|1| - содержимое бит, бинарные числа
|0|  6  |  0  |  0  |  0  |  1  | - содержимое бит, восьмеричные числа
```

### `(Rn)` Мода 1, косвенно-регистровый режим адресации

Две формы записи, или `INC (R3)`, или `INC @R3`.

Как имея регистр, доступиться к памяти? Адрес в памяти занимает 16 бит, размер регистра тоже 16 бит. То есть регистр может хранить число, которое можно считать адресом какой-то ячейки памяти.

Три варианта объяснения одного и того же:

* В регистре `Rn` находится число. Это число - адрес в памяти.
* Регистр содержит адрес операнда.
* В регистре лежит номер ячейки памяти, где лежит значение.

```cpp
adr = reg[n]
val = mem[adr] 
```

![mode1.png](https://stepik.org/media/attachments/lesson/325592/mode1.png)

Если в регистре `R3` лежит число 1000, то `INC (R3)` возьмет это число 1000, пойдет в **память** по адресу 1000, найдет там число 5 и заменит его на 6.

Очень похоже на оператор `*` в языке Си. `*p` - содержимое переменной `p` трактовать как адрес, пойти по этому адресу, взять/записать значение по этому адресу в памяти.

#### Пример кодирования мнемоники

```cpp
inc (R3)
```
команда кодируется как
```
|15            8|7             0| - номера бит
|0|0|0|0|1|0|1|0|1|0|d|d|d|d|d|d| - содержимое бит, бинарные числа
|0|  0  |  5  |  2  |  D  |  D  | - содержимое бит, восьмеричные числа
```
Запишем моду 1 и регистр 3 в аргумент:
```
|15            8|7             0| - номера бит
|0|0|0|0|1|0|1|0|1|0|m|m|m|r|r|r| - содержимое бит, бинарные числа
|0|0|0|0|1|0|1|0|1|0|0|0|1|0|1|1| - содержимое бит, бинарные числа
|0|  0  |  5  |  2  |  1  |  3  | - содержимое бит, восьмеричные числа
```

### (Rn)+, мода 2, автоинкрементный режим адресации

С помощью этого режима удобно перебирать массив чисел.

Пример использования:
```cpp
INC (R3)+
```
Как работает режим:

* Регистр содержит адрес операнда, 
* по этому адресу лежит значение,
* содержимое **регистра** увеличивается на 2 или на 1 (если это байтовая операция на регистрах R0..R5)

**Регистры R6 и R7 всегда увеличиваются на 2.**

Потому что если мы увеличим регистр `R7` на 1, его значение станет нечетным. По этому нечетному адресу пытаемся читать следующую команду, а у нас все слова начинаются по четным адресам. Машина сломалась.

Псевдокод:
```cpp
adr = reg[n]
val = mem[adr]
reg[n] += 2    (или 1)
```
Как видите, это почти режим 1, только **потом** значение регистра увеличивается.

Плюс отрабатывается **после** нахождения адреса и значения, поэтому его пишут в конце аргумента `(R3)+`.

![mode2.png](https://stepik.org/media/attachments/lesson/325592/mode2.png)

Если в регистре `R3` лежит число 1000, то `INC (R3)` возьмет это число 1000, пойдет в **память** по адресу 1000, найдет там число 5.
В регистре `R3` станет число 1002, в памяти число 5 заменится на 6.

Мода 0 позволяет обращаться к регистру, мода 1 позволяет обращаться к памяти. Зачем другие режимы? Они введены, чтобы программа была короче. Если в регистре R1 адрес элемента массива из чисел и мы хотим просуммировать эти числа, нужно считывать число по адресу из этого регистра и увеличивать значение так, чтобы регистр указывал на следующий элемент массива (содержал его адрес). Пусть сумма накапливается в `R5`. То есть вместо кода
```cpp
add (R1), R5   ; число по адресу, лежащему в R1, добавили в R5
add #2, R1     ; этот адрес увеличили на 2
```
можно написать короче
```cpp
add (R1)+, R5  ; прибавили число, увеличили адрес
```

Почему адрес может увеличиваться на 1, а не на 2? Команда копирования может работать с байтами `movb`, массив чисел может быть таким, что одно число занимает 1 байт. Тогда для адресации по этому массиву нужно будет добавлять +1 к адресу после обработки ячейки по этому адресу.

#### Пример кодирования мнемоники

```cpp
inc (R3)+
```
команда кодируется как
```
|15            8|7             0| - номера бит
|0|0|0|0|1|0|1|0|1|0|d|d|d|d|d|d| - содержимое бит, бинарные числа
|0|  0  |  5  |  2  |  D  |  D  | - содержимое бит, восьмеричные числа
```
Запишем моду 2 и регистр 3 в аргумент:
```
|15            8|7             0| - номера бит
|0|0|0|0|1|0|1|0|1|0|m|m|m|r|r|r| - содержимое бит, бинарные числа
|0|0|0|0|1|0|1|0|1|0|0|1|0|0|1|1| - содержимое бит, бинарные числа
|0|  0  |  5  |  2  |  2  |  3  | - содержимое бит, восьмеричные числа
```

### `#nn` мода 2 по регистру R7, непосредственный режим адресации

**Работает абсолютно так же, как мода 2**, разобранная раньше. Разница только в условном обозначении, когда пишем программу в мнемониках.

```cpp
mov #3, R1
```
Этот код работает так же как
```cpp
mov (R7)+, R1   
.WORD 3         ; положить в это слово число 3
```

![mode2_pc.png](https://stepik.org/media/attachments/lesson/325592/mode2_pc.png)

* Пусть команда `mov` лежит по адресу 1004. Она закодирована как 012701.
* В следующем слове по адресу 1006 пусть лежит число 3.
* В главном цикле обработки команд (прочитать команду, разобрать команду, выполнить команду) сразу после чтения команды, `pc` увеличивается на 2 еще до разбора команды и её аргументов. То есть после чтения команды (слова по адресу 1004), `pc` увеличивается на 2 и в R7 лежит число 1006.
* Разбираем первый аргумент, 27. Из `R7` читаем 1006, это адрес, идем по нему и получаем число 3. `R7` сразу увеличилось на 2. В `pc` адрес следующей команды, которую нужно разобрать.

Псевдокод такой же:
```cpp
adr = reg[7]
val = mem[adr]
reg[n] += 2    (или 1)
```
**Во 2 моде по 7 регистру изменяется только мнемоника**. Но никто вам не мешает писать `(R7)+` и использовать `.WORD` для размещения числа.
 
### Экономия памяти

Теперь мы можем сравнить в какой код преобразуются фрагменты кода.

```cpp
add (R1), R5   ; число по адресу, лежащему в R1, добавили в R5
add #2, R1     ; этот адрес увеличили на 2
```
кодируется в 3 слова:
```cpp
061105
062701
000002
```
Код, который делает то же самое:
```cpp
add (R1)+, R5  ; прибавили число, увеличили адрес
```
кодируется в 1 слово:
```cpp
062105
```
Экономия памяти в 3 раза. Разнообразие режимов адресации делает программу читабельнее и короче.

### @(Rn)+, мода 3, косвенный автоинкрементный режим адресации

С помощью этого режима удобно перебирать массив адресов (то есть указателей, например, адресов строк).

Режим очень похож на 2 моду, но добавляется еще одно разыменование. То, что во 2 моде было значением, в третьей моде трактуется как адрес и уже по этому адресу берется значение.

Пример использования:
```cpp
INC @(R3)+
```
Как работает режим:

* Регистр содержит адрес операнда, 
* по этому адресу лежит число,
* **это число - тоже адрес, по этому адресу берется значение**,
* содержимое **регистра** увеличивается **всегда на 2**.

Потому что в этом регистре лежит адрес **слова** (которое адрес), даже если это байтовая операция.

Псевдокод:
```cpp
adr = reg[n]
adr = mem[adr]
val = mem[adr]    добавилось еще одно разыменование
reg[n] += 2       всегда 2
```

Плюс отрабатывается **после** нахождения адреса и значения, поэтому его пишут в конце аргумента `@(R3)+`.

![mode3.png](https://stepik.org/media/attachments/lesson/894646/mode3.png)

Если в регистре `R3` лежит число 1000, то `INC @(R3)+` возьмет это число 1000, пойдет в **память** по адресу 1000, найдет там число 202. Пойдет в памяти по адресу 202 и найдет там число 5.
В регистре `R3` станет число 1002, в памяти число 5 заменится на 6. Число 202 останется без изменений.

### @#nn  мода 3, регистр R7, абсолютный режим

Используется для "значение по указанному адресу"

```cpp
mov @#202, R1;  значение по адресу 202, записать в R1
```
Работает так же, как мода 3 по любому другому регистру. Отличается только запись в мнемонике.

Псевдокод:
```cpp
adr = reg[7]
adr = mem[adr]
val = mem[adr]    добавилось еще одно разыменование
reg[n] += 2       всегда 2
```
![mode3_pc.png](https://stepik.org/media/attachments/lesson/894646/mode3_pc.png)

Конечный адрес хранится в слове сразу за командой. То есть команда по адресу 1004

```cpp
mov @#202, R1
```
кодируется так:
```cpp
1004: 013701
1006: 000202
```

* Пусть команда `mov` лежит по адресу 1004. Она закодирована как 013701.
* В следующем слове по адресу 1006 пусть лежит число 202, а по адресу 202 пусть лежит число 5.
* Как только мы прочитали команду из 1004 адреса, `PC` стало равно 1006. Это не разбор моды, это главный цикл обработки команд. Читаем новую команду и **сразу** увеличиваем `PC` на 2. Теперь в `R7` лежит число 1006.
* Разбираем первый аргумент, 37. Из `R7` читаем 1006, это адрес, идем по нему и получаем число 202. 
* Идем по адресу 202 и получаем число 5.
* `R7` сразу увеличилось на 2. В `pc` адрес следующей команды, которую нужно разобрать.

### -(Rn), мода 4, автодекрементный режим

Моды 4 и 5 похожи на 2 и 3, но если раньше мы **увеличивали потом** значение регистра, то теперь мы **сначала уменьшим** значение регистра. Чтобы не забывали, что уменьшаем сначала, мы пишем знак `-` спереди.

Эти моды используются для перебора массива чисел и массива адресов с конца в начало.

Пример использования:
```cpp
INC -(R3)
```
Как работает режим:

* Содержимое **регистра** уменьшается на 2 или на 1 (если это байтовая операция на регистрах R0..R5)
* Регистр содержит адрес операнда, 
* по этому адресу лежит значение.

**Регистры R6 и R7 всегда изменяются на 2.**

Потому что если мы уменьшим регистр `R7` на 1, его значение станет нечетным. По этому нечетному адресу пытаемся читать следующую команду, а у нас все слова начинаются по четным адресам. Машина сломалась.

Псевдокод:
```cpp
reg[n] -= 2    (или 1)
adr = reg[n]
val = mem[adr]
```
Как видите, это почти режим 1 или 2, только **сначала** значение регистра уменьшается.

Минус отрабатывается **до** нахождения адреса и значения, поэтому его пишут в начале аргумента `-(R3)`.

Ещё пример использования:
```
mov -(R3), R1
```

![mode4.png](https://stepik.org/media/attachments/lesson/894646/mode4.png)

Код работает следующим образом:

* Пусть в `R3` записано число 1002, а по адресу 1000, записано число 5. 
* `mov -(R3), R1` - первый аргумент `-(R3)`.
* Вычитаем 2 из содержимого регистра `R3`, там теперь число 1000.
* Число 1000 считаем адресом и читаем значение по этому адресу, число 5.
* Записываем 5 во второй аргумент команды, регистр `R1`.

### @-(Rn) мода 5, косвенный автодекрементный режим адресации

С помощью этого режима удобно перебирать массив адресов (то есть указателей, например, адресов строк) с конца.

Режим очень похож на 4 моду, но добавляется еще одно разыменование. То, что во 4 моде было значением, в пятой моде трактуется как адрес и уже по этому адресу берется значение.

Или же третья мода, у которой вместо "**потом увеличьте** значение регистра на 2" работает "**сначала уменьшите** значение регистра на 2".

```cpp
INC @-(R3)
```
Как работает режим:


* Содержимое **регистра** уменьшается **всегда на 2**,
* регистр содержит адрес операнда, 
* по этому адресу лежит число,
* **это число - тоже адрес, по этому адресу берется значение**.


Псевдокод:
```cpp
reg[n] -= 2       всегда 2
adr = reg[n]
adr = mem[adr]
val = mem[adr]    добавилось еще одно разыменование
```

Минус отрабатывается **до** нахождения адреса и значения, поэтому его пишут сначала аргумента, полученный результат разыменовываем `@-(R3)`.

![mode5.png](https://stepik.org/media/attachments/lesson/894646/mode5.png)

* Если в регистре `R3` лежит число 1002, то `INC @-(R3)` изменит значение регистра на -2, то есть в `R3` лежит число 1000.
* Возьмет это число 1000, пойдет в **память** по адресу 1000, найдет там число 206. 
* Пойдет в памяти по адресу 206 и найдет там число 5.

В памяти число 5 заменится на 6. Число 206 останется без изменений.
### X(Rn), мода 6, индексный режим адресации

В языках программирования высокого уровня есть понятие массива элементов, к одному элементу обращение идет по его номеру (индексу) в массиве. Например, `a[i]` - обращение к элементу с номером `i` массива `a`. В языке Си эта выражение эквивалентно другому, через адресную арифметику, `*(a + i)`, где `a` - это еще и адрес начала массива.

Если адрес начала массива хранится в регистре `R1`, то доступ к адресу на 2 меньше будет записано как `2(R1)` 

`X(Rn)` - **адрес = содержимое регистра Rn + сдвиг Х**.

Пример использования:
```cpp
mov 4(R3), R1
``` 

* В следующем слове программы хранится число `X` - смещение. **Читаем это число и сразу же увеличиваем `pc` на 2**. Потому что `pc` должно содержать адрес очередной команды программы.
* Число в регистре - это адрес.
* Прибавляем к адресу смещение `X` и по полученному адресу берем значение.

Псевдокод:

```cpp
x = mem[pc]     // прочитали очередное слово в коде
pc += 2
adr = reg[n]    // адрес указателя
adr = adr + x   // адрес указателя со смещением
val = mem[adr]  // разыменование
```

![mode6.png](https://stepik.org/media/attachments/lesson/894648/mode6.png)

* Пусть по адресу 1006 лежит команда `mov 4(R3), R1`, то есть число `016301` и тогда по адресу 1010 лежит число 4.
* В `R3` лежит число 200, а под адресу 204 лежит число 15.
* После чтения команды `pc` становится равным 1010.
* По адресу 1010 берем число 4, это смещение, `pc` сразу увеличивается на 2 и становится 1012.
* В `R3` лежит число 200, добавляем к нему смещение 4 и по адресу 204 берем значение 15.

**Сдвиг `X` может быть отрицательным**.

### nn, мода 6 по 7 регистру, относительный режим адресации

Работает так же, как 6 мода по любому другому регистру, отличается только записью в мнемониках.

`mov 100, R3` - число **по адресу** 100 записать в `R3`. Получить число по адресу 100 можно используя третью моду `@#100`. 

Зачем использовать разные моды для одной и той же цели - выходит за рамки нашего курса. Если интересно, можете почитать в комментариях к шагу об относительном расположении программ и данных в памяти.

![mode6_pc.png](https://stepik.org/media/attachments/lesson/894648/mode6_pc.png)

Разберем, как закодирована и как работает команда `mov 204, R1`, которая лежит по адресу 1006.

* По адресу 1006 лежит число `016701`. После того, как его прочли `pc` стало 1010 и указывает на следующее слово в программе.
* Пока не знаем, чему равно это слово, обозначим его `???`. Читаем его и `pc` **увеличивается на 2** и равно 1012.
* 1012 + `???` = 204 - адрес, по которому должны прочитать значение 15. 

Из уравнения найдем, что `???` это -606. Для проверки можете сложить столбиком (напоминаем, система восьмеричная, 6+4=12, 2+6=10)
```cpp
 204
+606
----
1012
```
Хорошо, что у нас есть компилятор, который преобразует команду в мнемониках `mov 204, R1` в машинный код и сам находит это число.

Вспомним, что [отрицательные числа в дополнительном коде](https://stepik.org/lesson/777149/step/4?unit=779630) представляются так, чтобы при суммировании с положительным числом той же величины у нас получалось переполнение.
```
 000606
+??????
------- 
 200000 в бинарном виде это 10 000 000 000 000 000, то есть 17 бит
```
Искомое число 
```
 000606   это 606
+177172   это -606
------- 
 200000
```
Убеждаемся, что суммирование дает нужный адрес:
```
 001012
+177172
-------
 200204 (с учетом переполнения) или
 000204 (если учитывать только 16 бит этого числа)
```
То есть команда `mov 204, R1` по адресу 1010 в файле листинга будет представлена в виде двух слов как
```cpp
001010 : 016701 mov 204, R1
001012 : 177172
```

### @X(Rn) мода 7, косвенный индексный режим адресации

В языке Си эта мода аналогична применению к элементу массива операции разыменование `*a[i]`.

Добавим ещё одно разыменование к моде 6.

`X(Rn)` - **адрес = содержимое регистра Rn + сдвиг Х**, по этому адресу у нас хранится адрес, идем по нему и получаем число.

Пример использования:
```cpp
mov @4(R3), R1
``` 

* В следующем слове программы хранится число `X` - смещение. **Читаем это число и сразу же увеличиваем `pc` на 2**. Потому что `pc` должно содержать адрес очередной команды программы.
* Число в регистре - это адрес.
* Прибавляем к адресу смещение `X` и по полученному адресу берем число, это адрес.
* По полученному адресу берем значение.

Псевдокод:

```cpp
x = mem[pc]     // прочитали очередное слово в коде
pc += 2
adr = reg[n]    // адрес указателя
adr = adr + x   // адрес указателя со смещением
adr = mem[adr]  // добавили разыменование
val = mem[adr]  // разыменование
```

![mode7.png](https://stepik.org/media/attachments/lesson/894648/mode7.png)

* Пусть по адресу 1006 лежит команда `mov @4(R3), R1`, то есть число `017301` и тогда по адресу 1010 лежит число 4.
* В `R3` лежит число 200, а под адресу 204 лежит число 100, по адресу 100 лежит число 5.
* После чтения команды `pc` становится равным 1010.
* По адресу 1010 берем число 4, это смещение, `pc` сразу увеличивается на 2 и становится 1012.
* В `R3` лежит число 200, добавляем к нему смещение 4 и по адресу 204 берем число 100.
* Это число 100 трактуем как адрес, идем по адресу 100 и берем там число 5. Значение первого аргумента `@4(R3)` будет 5.

### @nn - мода 7 по регистру 7, косвенный относительный режим адресации

В моде 6 когда обращались к `204` мы брали **число** по адресу 204, а теперь в `@204`, читаем из ячейки 204 **адрес** и идем по этому адресу.

Работает так же, как 7 мода по любому другому регистру, отличается только записью мнемоники.

Сравните переходы в памяти для разбора 6 и 7 моды по 7 регистру:

![mode6_pc.png](https://stepik.org/media/attachments/lesson/894648/mode6_pc.png) ![mode7_pc_patch.png](https://stepik.org/media/attachments/lesson/894648/mode7_pc_patch.png)


Разберем, как закодирована и как работает команда `mov @204, R1`, которая лежит по адресу 1006.

* По адресу 1006 лежит число `017701`. После того, как его прочли `pc` стало 1010 и указывает на следующее слово в программе.
* Как мы выяснили на предыдущем шаге, тут лежит слово -606, в восьмеричном дополнительном коде это 177172. Читаем его и `pc` **увеличивается на 2** и равно 1012.
* 1012 + -606 = 204 - адрес, по этому адресу хранится число 100.
* Идем по адресу 100 и читаем число 5.

### Работа программы `mov -(pc), -(pc)`

Разберем как работает программа, состоящая из единственной команды, которую мы положим по адресу 1000:

```
. = 1000
mov -(pc), -(pc)
```
Оба аргумента - это 4 мода по 7 регистру, то есть код программы это `014747` (всего одно слово).

* Начало работы программы: `pc = 1000`, по адресу 1000 лежит число 014747.
* Прочитали слово по адресу 1000, `pc = 1002`.
* Разбираем первый аргумент `-(pc)`, находим **что** копируем:
    * `pc -= 2`, получим `pc = 1000` - это адрес, а **значение первого аргумента - число `014747`**, которое лежит по этому адресу.
* Разбираем второй аргумент `-(pc)`, находим куда копируем:
    * `pc -= 2`, получим `pc` равное `1000 - 2 = 776` - это адрес, куда будем копировать, обратите внимание, `pc = 776`
* Выполняем команду, записываем число `014747` по адресу 776.
* Далее разбираем следующую команду - читаем слово по адресу 776 и разбираем его. То есть наше слово копируется каждый раз на одно выше.

Программа бесконечно работает и копирует свой код в память. Перед вами пример **вируса**. Его размер 2 байта. 

Эта программа есть в интеграционных тестах. Убедитесь, что она много раз копирует себя. Она может останавливаться и падать, а может продолжать работу бесконечно. Любой вариант с множественным копированием - это корректное выполнение теста.
## SOB - команда с аргументом типа NN

В [таблице команд](https://stepik.org/lesson/347539/step/1) посмотрим какой код операции и какие аргументы у команды SOB

| Мнемоника | Опкод | NZVC | Описание | Замечания |
|----|----|----|----|----|
| **SOB** r, a | 077RNN | `----` | Subtract One and Branch | PC=PC-2*NN |

* `077` - код операции, 7 бит (это 16 - (3+6))
* R - номер регистра, 3 бита
* NN - сдвиг, 6 бит, беззнаковое (положительное) число

Разберемся, что такое NN и как реализуется переход по адресу `a`.

Код:
```cpp
LOOP:
    mov (R2)+, R3             ; R3 = *R2; R2++ записывает в R3 число, лежащее по адресу, хранимому в R2, этот адрес увеличивается
    add R3, R0                 ; очередное число прибавляется к текущей сумме
    sob R1, LOOP               ; if (--R1 != 0) goto LOOP;
```
Листинг этого кода:
```cpp
001012:		LOOP:
001012:		    mov (R2)+, R3             ; R3 = *R2; R2++ записывает в R3 число, лежащее по адресу, хранимому в R2, этот адрес увеличивается
	 012203
001014:		    add R3, R0                 ; очередное число прибавляется к текущей сумме
	 060300
001016:		    sob R1, LOOP               ; if (--R1 != 0) goto LOOP;
	 077103
001020:
```
То есть метка LOOP имеет значение 1012, `sob R1, LOOP` кодируется в 077103.

* 077 - код операции,
* 1 - номер регистра, R1
* 03 - это NN. Посмотрим, как оно связано с меткой LOOP.

Адрес - это 16-битное число. Если мы будем хранить адрес перехода, то в 16 бит и опкод команды, и номер регистра, и адрес перехода не поместится. SOB создавался как команда для цикла, в цикле нужно переходить назад по адресам и переходить недалеко.

Когда мы разбираем команду sob, которая расположена по адресу 1016, pc уже равно 1020 (адресу следующего слова).

Нужно перейти на адрес 1012. То есть выполнить `pc = 1012`, то есть, учитывая текущее значение pc, это `pc = pc - 6`, то есть 1020 - 6 = 1012. В NN хранится смещение, поэтому в SOB мы можем только возвращаться на метку с меньшим адресом и недалеко.

Адрес команды sob - четный, адрес метки - тоже четный. Смещение всегда будет **четное** количество байт (у нас 6), то есть в бинарном виде всегда оканчиваться 0. Из 6 бит на смещение 1 бит будет всегда хранить 0. Это не экономно. Поэтому в NN записывают смещение без последнего 0 (или смещение на количество слов, а не байт). Теперь в NN можно записать число в 2 раза больше. Формула для вычисления адреса перехода, то есть нового значения `pc` будет pc = pc - 2 * NN.
## Команды ветвления (условные операторы)
С помощью команды SOB можно организовать цикл на заданное количество итераций. Для цикла с условием (например, суммируем последовательность чисел до 0) нужно уметь делать условные и безусловные переходы по адресу.
Кроме того, хочется уметь детектировать ошибки вычислений (переполнение, знаковое переполнение).
В обычной программе до 30% машинных команд приходится на *if условие then переход по адресу*, даже без конструкции *else*. Значит, чтобы программа была короче, набор команд ветвления должен быть достаточно мощным, а сами команды - компактными. 

Чаще всего выполняются проверки:

* `if (x == 0)`
* `if (x != 0)`
* `if (x < 0)`, `> 0`,  `<= 0`, `>= 0`

Конструкции вида `x < y` сводятся к сравнению с нулем `x - y < 0`.

Проверки нужно делать быстро, то есть проверки должны быть реализованы на уровне "железа" в виде электросхем. Эта часть не должна сильно усложнять архитектуру, решение должно быть простым. В PDP-11 эта задача была решена через флаги состояния.

Для каждой типичной проверки создадим ячейку в 1 бит, в которой будем писать результат этой проверки для последней выполненной команды. Критериев проверки несколько, значит нужно несколько бит. Эти биты объединяются в **слово состояния процессора**, **Process State Word, PSW**. В нем много флагов. Подробно разберем только 4 флага N, Z, V, C. Реализуем только 3 флага, NZC, без флага V.

PSW - это отдельная ячейка, не память RAM и не регистры. Состоит из флагов, флаг - это 1 бит, в нем может быть 1 (флаг выставлен/поднят) или 0 (флаг не выставлен).

Команды могут изменять эти флаги или опрашивать их состояние и совершать действия. Разберем это на примерах.

#### NZVC

* **Z** (**z**ero) - флаг выставлен в 1, если **результат команды 0**; иначе значение флага 0.
* **N** (**n**egative) - флаг выставлен в 1, если **результат команды** `< 0`; иначе значение флага 0.
* **C** (**c**arry, дополнительный бит, считайте, что сложение проходит в 17 битах, а не в 16. И флаг С - это тот самый старший, дополнительный бит).
* **V** (o**V**erflow) - знаковое переполнение, когда результат операции имеет неверный знак).

Напомним, чем отличается переполнение от знакового переполнения.

#### Сложим числа `-1 + 1`

```
C|15            8|7             0| - номера бит и флаг С
 |0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|1| - 1
 |1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1| - -1
----------------------------------
1|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0| - 1+(-1) = 0 в слове и С=1
```
* `C=1`, возникло переполнение,
* `V=0`, никаких неожиданностей в знаке результата нет,
* `N=0`, знаковый бит результата 0.
* `Z=1`, результат 0.

#### Сложим два очень больших положительных числа так, чтобы получилось отрицательное число

```
C|15            8|7             0| - номера бит и флаг С
 |0|1|0|0|0|0|0|0|0|0|0|0|0|0|0|0| - большое положительное число
 |0|1|0|0|0|0|0|0|0|0|0|0|0|0|0|0| - большое положительное число
----------------------------------
0|1|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0| - отрицательное число
```
* `C=0`, переполнения нет. 
* Но есть **знаковое переполнение**, результат операции удивляет математиков, флаг `V=1`.
* Флаг `N=1`, так как результат отрицательный.
* Флаг `Z=0`, так как результат не равен 0.

#### -1 + -1

```
C|15            8|7             0| - номера бит и флаг С
 |1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1| - -1
 |1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1| - -1
----------------------------------
1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|0| - -2
```
* `C=1`, возникло переполнение,
* `V=0`, никаких неожиданностей в знаке результата нет,
* `N=1`, знаковый бит результата 0.
* `Z=0`, результат 0.
### Описание выставления флагов командами

В таблице команд ассемблера есть столбец NZVC. В нем описано, как изменяются флаги по результату работы команды.

| Обозначение | Означает |
|----|----|
| `0` | Флаг выставляется в 0 |
| `1` | Флаг выставляется в 1 |
| `*` | Флаг выставляется по результату операции |
| `-` | Флаг не изменяется |

Пример описания команд:

| Мнемоника | Opcode | NZVC | Описание | Комментарии |
|-----|----|----|----|----|
| ADD s, d | 06SSDD | `****` | Add | d = s + d |
| BR   a      | 0004XX   | `----`   | Branch  | PC=PC+2*XX   | 
| MOVb s,d    | B1SSDD   | `**0-`   | Move                         | d=s          | 
| TSTb d      | B057DD   | `**00`   | Test  | d            | 
| CMPb s,d    | B2SSDD   | `****`| Compare                      | s-d          | 

* `MOV` и `MOVB` - выставляют только флаги N и Z, флаг С не трогают, V=0.
* `BR` - не изменяет флаги.
* `TST` и `TSTB` - выставляет флаги N и Z, обнуляя V и С.

Команда **TST** (от слова test, проверить) используется для выставления по аргументу *d* флагов.

Аналогично, команда **CMP** (от слова compare, сравнить), вычисляет разность аргументов *s-d* и по этой разности выставляет все флаги.

Заметим, что байтовые версии команд **TSTB** и **CMPB** флаг `N` выставляют по знаковому биту одного байта, то есть биту с номером 7.

Эти команды нужно будет реализовать в эмуляторе. О команде `BR` мы расскажем подробнее позже.

### Кодирование команд set/clear флагов (condition code operations) 

* **CLx** - очистить (clear) флаг x; команды `CLN`, `CLZ`, `CLV`,`CLC` - флаг = 0.
* **SEx** - установить (set) флаг x; команды `SEN`, `SEZ`, `SEV`,`SEC` - флаг = 1.
* **CCC** - снять все флаги (clear all condition codes).
* **SCC** - установить все флаги (set all condition codes).
* **NOP** - холостой такт процессора (no operation), нужен, чтобы процессор, например, дождался чтения данных.

| Мнемоника | Opcode | NZVC | Описание | Комментарии |
|-----|----|----|----|----|
| CCC         | 000257   | `0000`   | Clear all Condition Codes    | {C,N,V,Z}=0  | 
| CLC         | 000241   | `---0`   | Clear Carry                  | C=0          | 
| CLN         | 000250   | `0---`   | Clear Negative               | N=0          | 
| CLV         | 000242   | `--0-`   | Clear Overflow               | V=0          | 
| CLZ         | 000244   | `-0--`   | Clear Zero                   | Z=0          | 
| NOP         | 000240   | `----`   | No Operation                 |              | 
| SCC         | 000277   | `1111`   | Set all Condition Codes      | {C,N,V,Z}=1  | 
| SEC         | 000261   | `---1`   | Set Carry                    | C=1          | 
| SEN         | 000270   | `1---`   | Set Negative                 | N=1          | 
| SEV         | 000262   | `--1-`   | Set Overflow                 | V=1          | 
| SEZ         | 000264   | `-1--`   | Set Zero                     | Z=1          | 

Коды всех этих операций сделаны по следующему формату:

```
|15            8|7             0| - номера бит
|0|0|0|0|0|0|0|0|1|0|1|s|N|Z|V|C| - содержимое бит, бинарные числа
|0|  0  |  0  |  2  |  4+ |     | - содержимое бит, восьмеричные числа
```
* последние 4 бита соответствуют флагам NZVC, 1 - операция влияет на флаг, 0 - операция не влияет на флаг.
* s = 1, если флаг устанавливают, 0, если флаг обнуляют.

То есть команда `SEZ`, устанавливающая флаг Z:
```
|15            8|7             0| - номера бит
|0|0|0|0|0|0|0|0|1|0|1|s|N|Z|V|C| - формат кодирования команд
|0|0|0|0|0|0|0|0|1|0|1|1|0|1|0|0| - SEZ
|0|  0  |  0  |  2  |  6  |  4  | - восьмеричный код команды.
```
Команда `ССС` - обнуление всех флагов:
```
|15            8|7             0| - номера бит
|0|0|0|0|0|0|0|0|1|0|1|s|N|Z|V|C| - формат кодирования команд
|0|0|0|0|0|0|0|0|1|0|1|0|1|1|1|1| - CCC
|0|  0  |  0  |  2  |  5  |  7  | - восьмеричный код команды.
```
### Переход по адресу

Что такое "перейти в программе по адресу Х"? Это значит, следующая команда будет читаться из адреса Х. То есть `PC = X` и переход сделан.
#### MOV

В ассемблере это можно написать так:
```cpp
    mov #X, R7
    ...
X:  ...
```
#### JMP

Именно так работает команда **JMP** (jump, прыжок) - переход по указанному адресу
```cpp
    jmp X
    ...
X:  ...
```
Плюс: может перейти по любому адресу, никаких ограничений.
Минус: занимает 2 слова, а нам хочется и условие, и переход уместить в одном слове.
#### SOB

Мы уже знаем еще одну команду, которая проверяет условие, переходит по адресу и умещается в одном слове, **SOB**:
```cpp
LOOP:  
    ...
    sob R1, LOOP
```
Минусы: переход только назад, в сторону уменьшения адреса, не более 077 слов назад. Потому что аргумент NN, на сколько слов назад мы переходим, содержит 6 бит.
#### BR

**Безусловный** переход, кодируемый в одно слово **BR**. Разберем эту команду.
### BR : 0004XX

**Безусловный** переход, кодируется в одно слово с помощью сдвига, то есть на сколько слов вперед или назад нужно изменить значение PC.

* ХХ - 8 бит (кодирует на сколько слов изменим текущий адрес).
* ХХ - **знаковое**, то есть можно переходить по адресам в памяти как вперед (в сторону больших адресов), так и назад (в сторону меньших адресов).
* PC = PC + XX * 2

#### Пример прыжка вперед

```cpp
1000: 000402    br A
1002: 012700    mov #2, R0
1004: 000002
1006: 012701 A: mov #3, R1
1010: 000003  
```
Когда разбирается команда `br A`, PC=1002.

Надо перейти на 2 слова и попасть на адрес 1006. То есть в ХХ кодируем сдвиг 2.

```
|15            8|7             0| - номера бит
|0|0|0|0|0|0|0|1|x|x|x|x|x|x|x|x| - код операции
|0|0|0|0|0|0|0|1|0|0|0|0|0|0|1|0| - содержимое бит, бинарное число
|0|  0  |  0  |  4x |  X  |  X  | - содержимое бит, восьмеричные числа
|0|  0  |  0  |  4  |  0  |  2  | - содержимое бит, восьмеричные числа
```
Заметим, что цифра 4 складывается как из 1 от кода операции, так и из двух бит аргумента. В этом примере это 00 и получаем 100 (бинарное), то есть 4 (восьмеричное).

Команда `br A` кодируется как 000402.

#### Пример прыжка назад

```cpp
1000: 012700    mov #2, R0
1002: 000002
1004: 000775    br A
1006: ...
```
Когда разбирается команда `br A`, PC=1006.

Надо перейти на 3 слова **назад** и попасть на адрес 1000. То есть в ХХ кодируем сдвиг -3.

Разберем, как из кода операции 0004XX и сдвига XX=-3 получается 000735.

-3 надо закодировать в 8 битах аргумента ХХ, это 11111101 (бинарное). Разобъем его на тройки, `11 111 101`. То есть первые `11` войдут в восьмеричное число, которое формируется из кода операции `1` и аргумента `11`. Получим `111`, то есть 7.

`br A` кодируется как 000775 (при коде операции 000400). Обратите внимание, цифра 4 превратилась в цифру 7.

```
|15            8|7             0| - номера бит
|0|0|0|0|0|0|0|1|x|x|x|x|x|x|x|x| - код операции
|0|0|0|0|0|0|0|1|1|1|1|1|1|1|0|1| - содержимое бит, бинарное число
|0|  0  |  0  |  4x |  X  |  X  | - код операции, восьмеричные числа
|0|  0  |  0  |  7  |  7  |  5  | - содержимое бит, восьмеричные числа
```
Как быстро в уме переводить отрицательный сдвиг в восьмеричные цифры? Заметим, что при сложении 8-битного положительного и соответствующего ему отрицательного числа, будет переполнение. Запишем получившийся 0 "честно", как 9-битное число:
```
8|7             0| - номера бит
 |x|x|x|x|x|x|x|x| - аргумент ХХ
 |0|0|0|0|0|0|1|1| - 3
 |1|1|1|1|1|1|0|1| - -3
------------------
1|0|0|0|0|0|0|0|0| - 3+(-3)
  4  |  0  |  0  |
```
То есть с переполнением будет 400. Вопрос: к какому **восьмеричному** числу надо прибавить 3, чтобы получилось 400? Это число 375. То есть -3 кодируется в *восьмеричном* 8-битовом виде как 375.

Добавим аргумент 375 к коду операции 000400, получим
```
000400
   375
------
000775
```

### Условные ветвления

Все команды условных ветвлений проверяют какое-то условие и переходят по адресу. То есть функция реализации команды должна проверять условие и вызывать функцию `do_br`. Например, команда **BPL** (branch if plus) проверяет, если флаг N равен 0, то переходит по адресу.

| Мнемоника | Opcode | NZVC   | Описание                   | Комментарии  |
| --------- | ------ | ------ | -------------------------- | ------------ |
| BCC  a    | 1030XX | `----` | Branch if Carry Clear      | If C=0       |
| BCS  a    | 1034XX | `----` | Branch if Carry Set        | If C=1       |
| BEQ  a    | 0014XX | `----` | Branch if Equal            | If Z=1       |
| BGE  a    | 0020XX | `----` | Branch if Greater or Equal | If NxV=0     |
| BGT  a    | 0030XX | `----` | Branch if Greater Than     | If Zv{NxV}=0 |
| BHI  a    | 1010XX | `----` | Branch if Higher           | If CvZ=0     |
| BHIS a    | 1030XX | `----` | Branch if Higher or Same   | If C=0       |
| BLE  a    | 0034XX | `----` | Branch if Less or Equal    | If Zv{NxV}=1 |
| BLT  a    | 0024XX | `----` | Branch if Less Than        | If NxV=1     |
| BLO  a    | 1034XX | `----` | Branch if Lower            | If C=1       |
| BLOS a    | 1014XX | `----` | Branch if Lower or Same    | If CvZ=1     |
| BMI  a    | 1004XX | `----` | Branch if Minus            | If N=1       |
| BNE  a    | 0010XX | `----` | Branch if Not Equal        | If Z=0       |
| BPL  a    | 1000XX | `----` | Branch if Plus             | If N=0       |
| BR   a    | 0004XX | `----` | Branch                     | PC=PC+2*XX   |
| BVC  a    | 1020XX | `----` | Branch if Overflow Clear   | If V=0       |
| BVS  a    | 1024XX | `----` | Branch if Overflow Set     | If V=1       |
## Внешние устройства

Внешними устройствами по отношению к CPU и RAM являются:

* дисплей, клавиатура, мышь, принтер и прочие устройства ввода-вывода;
* внешняя память (жесткие диски, магнитные ленты, флешки и тп).

Взаимодействие с ними происходит через **регистры внешних устройств**. Но это не дополнительная память (как PSW), а **последние 8 кБ** RAM. То есть каждому устройству, например дисплею, соответствуют конкретные ячейки памяти с фиксированными адресами.

То есть за каждым устройством закреплен фиксированный адрес и эти адреса описаны в документации.

* Монитор:
    * 0177564 - статус и команды монитора,
    * 0177566 - данные, которые выводятся на монитор.
* Клавиатура:
    * 0177560 - статус и команды клавиатуры,
    * 0177562 - данные, которые прочитаны с клавиатуры.

Как в ассемблере работают с этими константами, чтобы выводить символы на монитор и читать их ввод с клавиатуры?
### Печать одного символа в программе 

Для того, чтобы символ был выведен на монитор, его ASCII код всего-навсего нужно поместить в байт с адресом **0177566**.

ASCII-код символа в ассемблере записывается как **одинарная кавычка** и за ней символ, например, `'a` - ASCII-код буквы `a`.

Похоже на запись символьной константы в языке Си `'a'`.

Чтобы не писать длинные константы (и не ошибаться в них), в ассемблере используют псевдокоманды, чтобы определить константы:
```cpp
ostat = 177564  ; регистр состояния дисплея дисплея
odata = 177566  ; регистр данных дисплея
```
Далее командой `movb` копируем ASCII-код по адресу 177566:
```
movb #'a, @#odata   ; 3 мода
```
или 
```
movb #'a, odata     ; 6 мода
```
Написать таким образом на экран `hello` не получится:
```
movb #'h, odata
movb #'e, odata
movb #'l, odata
movb #'l, odata
movb #'o, odata
```
Почему? Потому что вывод символа на экран - очень долгая операция по сравнению с записью в RAM и командой процессора.

Мы записываем одно значение за другим на одно место в памяти. При этом шина данных передает данные в память быстрее, чем внешнее устройство успевает отрисовать очередной символ. Символы пишутся один поверх другого и таким образом, следующий символ затирает данные предыдущего еще до того, как его начали выводить на дисплей. То есть мы требуем рисовать новый символ, когда устройство еще рисует предыдущий и **не готово к работе**.

Для этого в регистре состояния устройства по адресу 177564 в бите номер 7 пишется флаг готовности устройства. 1 - устройство готово, 0 - устройство НЕ готово.

Напишем код на ассемблере, которое будет ждать готовности устройства. 7 бит - это знаковый бит по адресу 177564. Командой `TSTB` знаковый бит занесем в флаг `N` и будем в цикле проверять значение флага, пока он не станет N=1.

```
ostat = 0177564   ; TTO command and status register for PDP-11
odata = 0177566   ; TTO data register

    . = 1000
    mov    #'*, R0     ; В R0 ascii код символа * 
putchar:
    tstb   @#ostat     ; проверяем бит 7 в ostat (это знаковый бит!!!)
    bpl    putchar     ; if ( bit 7 == 0 ) перейти на метку putchar, устройство занято
    movb   R0, @#odata ; записываем ascii код в odata (вывод на экран)
    
    halt
```
**В эталонном эмуляторе без проверки бита готовности устройства, эмулятор не выводит символы**.

В вашем эмуляторе напишите код так, чтобы ваше устройство **всегда было готово**. То есть по адресу 0177564 в 7 бите всегда должна быть 1 (что будет в других битах - на ваше усмотрение, можно все биты заполнить единицами).

### Программный и аппаратный стек
#### Программный стек

Стек в ассемблере можно реализовать с помощью команды `MOV` и мод адресации.

Покажем пример стека на основе регистра `R3`. В регистре хранится адрес первой **пустой** ячейки, куда можно положить данные.

Пусть изначально `R3` указывал на адрес 2410:
```cpp
mov #2410, R3;  R3 = 2410
```
Кладем данные в стек (push):

```cpp
mov #17, (R3)+  ; положили в стек число 17
mov R1, (R3)+   ; положили в стек значение регистра R1
mov ADR, (R3)+  ; положили в стек число по адресу ADR
``` 
Обозначим на рисунке `c(R1)` - содержимое регистра `R1`, `c(ADR)` - слово в памяти по адресу `ADR`:

![стек в сторону больших адресов](https://stepik.org/media/attachments/lesson/320750/stack_plus.png)

Достаем данные из стека (pull):
```cpp
mov -(R3), R4
```
Стек реализован с помощью 2 и 4 моды адресации. Он растет в сторону больших адресов. Можно на тех же модах реализовать стек, растущий в сторону меньших адресов.

#### Программный стек (рост в сторону меньших адресов)

Возьмем тот же регистр `R3`:
```cpp
mov #2410, R3;  R3 = 2410
```
Кладем данные в стек (push):

```cpp
mov #17, -(R3)  ; положили в стек число 17
mov R1, -(R3)   ; положили в стек значение регистра R1
mov ADR, -(R3)  ; положили в стек число по адресу ADR
``` 

![стек в сторону меньших адресов](https://stepik.org/media/attachments/lesson/320750/stack_minus.png)

Достаем данные из стека (pull):
```cpp
mov (R3)+, R4
```
В регистре `R3` содержится адрес последней ячейки с данными.

Те же моды адресации, стек растет в другую сторону.

#### Доступ внутрь стека (индексная мода адресации)

По правилу работы со структурой данных "стек" мы кладем строго на вершину стека и берем строго с вершины. Внутрь не лезем. Но вы увидите дальше, что нам будет удобно брать числа не с вершины стека. Для этого можно использовать индексную моду адресации (она же мода 6).

Пусть регистр `R1` содержит адрес верхушки стека, число 2410 (адрес последних положенных данных, если стек рос в сторону меньших адресов). 

Специально взяли другой регистр, чтобы вы почувствовали, что **программный стек** можно организовать на любом регистре (кроме PC).

Хотим найти сумму всех чисел в стеке, не изменяя его. И положить сумму в регистр `R0`.

Индексная мода *n(Ri)* к содержимому регистра *Ri* прибавляет число *n* и это трактуется как *адрес*. То есть если в `R1` адрес начала массива, то `(R1)` - значение его нулевого элемента, то есть первая мода - это индексная с индексом 0.

Следующее слово в этом массиве лежит по адресу `2(R1)`. В языке Си мы привыкли для массива `a` получить элемент с индексом 2 как `a[2]`, а в ассемблере 2 пишется перед номером регистра.

Просуммируем 3 числа из стека. Специально берем числа в произвольном порядке:
```cpp
clr R5          ; обнулили регистр с суммой
add 6(R1), R5   ; R5 += 6066 (это мода 6)
add (R1), R5    ; R5 += 4022 (это мода 1)    
add 2(R1), R5   ; R5 += 17763 (это мода 6)
```

![индексная мода](https://stepik.org/media/attachments/lesson/320750/stack_in.png)

#### Проблемы организации программного стека

В стеке нужно следить, чтобы данные не затирали другие данные или инструкции программы.

Если стек растет в сторону больших адресов, можно выделить явно память и организовать стек в рамках выделенного участка памяти. Вы сами должны следить, чтобы не выходить за границы этого участка. Выделим память на 10 слов, начиная с адреса `B`:
```cpp
B:  .BLKW 10
```
Чуть проще организовать рост стека в сторону меньших адресов. Пусть наша программа начинается с адреса 1000, тогда организуем стек, растущий в строну меньших адресов, ровно над программой. Код программы идет вниз по адресам 1000, 1002, 1004 и так далее, данные в стеке идут вверх по адресам 776, 774, 772 и так далее.

```cpp
        .=1000
START:  mov #START, R4; R4 - указатель на вершину стека 
```
Если в стек кладутся только слова командой `mov`, или только байты командой `movb`, все хорошо. Но если в стек попытаться класть и слова, и байты вперемешку, то может оказаться такое, что положили слово по четному адресу, указатель на верхушку стека содержит четный адрес. Положили байт, указатель на верхушку стека стал содержать **нечетный** адрес и слово теперь в стек положить нельзя. 

```cpp
mov  #17, -(R4); R4 -= 2, стал равен 776, по адресу 776 записали слово 17.
movb #'z, -(R4); R4 -= 1, стал равен 775, по адресу 775 записали ascii-код символа z.
```

Надо руками добавлять "пустой байт" в стек, чтобы положить слово. При разборе стека тоже нужно помнить, что клали, чтобы пропустить "пустой байт" и не читать слово по нечетному адресу.
#### Аппаратный стек

Любая сложность - это потенциальный источник ошибок. Для того, чтобы работал стек с разнотипными данными, сделали **аппаратный стек на регистре `R6`**. При записи и чтении слова или байта, у нас адрес изменяется всегда на 2. Этот регистр так же называют **SP (stack pointer)**. Стек называется аппаратным, потому что существуют аппаратные инструкции, которые его используют. В архитектуре мод адресации заложено, что работа с `R6` - это всегда изменение значения регистра на 2 (для мод 2 и 4).
### Функции

Команды для передачи управления в функцию и возврата из нее неявно используют аппаратный стек на SP. Это команды:
* **JSR** (**J**ump to **S**ub**R**outine - переход к подпрограмме)
* **RTS** (**R**e**T**urn from **S**ubroutine - возврат из подпрограммы).

| Мнемоника    | Opcode   | NZVC   | Описание                  | Комментарии        | 
|----|----|----|----|----|
| JSR  r,d    | 004RDD   | `----`   | Jump to Subroutine           | r=PC,PC=d    | 
| RTS  r      | 00020R   | `----`   | Return from Subroutine       | PC=r,r=(SP)+ | 

То есть весь этот код записывается как:

```
024614 004567: jsr R5, PRINT ; команда занимает 2 слова, ибо адрес перехода DD
024616 021624: 
024620 ...     следующая команда, сюда надо вернуться
...
046444        PRINT:        ; начало подпрограммы
                ...
046552 000205: rts R5       ; вернулись по сохраненному адресу
```
### Что делает команда JSR Rn, adr

Неявно использует регистр `SP`.

* Сохраняет старое значение регистра **Rn** в стек.
* Адрес возврата записывает в регистр **Rn**.
* Переходит по указанному в **adr** адресу.

### Что делает команда RTS Rn

Неявно использует регистр `SP`. Действия **JSR** разворачиваются в обратном порядке.

* Переходит по указанному в **Rn** адресу (возврата).
* Восстанавливает старое значение регистра **Rn** из стека.

**Номера регистров в JSR и RTS для пары вызов-возврат в программе на ассемблере должны совпадать.** В эмуляторе это проверять не нужно.

## Директивы (псевдокоманды) ассемблера

Приведем список употребляемых в примерах директив как справочник. 

* **.= адрес** - разместить следующие команды, начиная с указанного адреса.
    * Пример:  `.=1000` следующий код размещается, начиная с адреса 1000
    * На самом деле, эта директива изменяет значение специальной переменной с именем . (точка), чье значение равно текущему адресу размещения машинного кода.
* **.BYTE** числа через запятую
    * размещает указанные числа по одному в байте (если число не помещается в байт, старшие разряды откидываются)
* **.BLKB N**
    * резервирует N байт в памяти, начиная с текущего адреса
* **.WORD числа через запятую**
    * размещает указанные числа по одному в слове
* **.BLKW N**
    * резервирует N слов в памяти, начиная с текущего адреса
* **.ASCII #текст#** - размещает в памяти символы указанного текста по одному в байте. Символ начала и конца текста может быть любой (в данном случае #). В последнем примере после запятой напечатаются \r\n (символы возврата каретки и новой строки), их ascii-коды в восьмеричной системе 15 и 12:
```
.ASCII #Hello, world!#
.ASCII SHello, world!S
.ASCII /Hello, world!/
.ASCII #Hello,# <015><012> #world!# 
```
* **.ASCIZ #текст#** - аналогично `.ASCII`, но в конце строки добавляет байт, содержащий ноль. Аналог строковой константы в Си, например, `"Hello, world!"`
* **.EVEN** - следующее слово гарантированно с четного адреса (пропускает 1 байт, если нужно). Нужно использовать после директив размещения, чтобы последующие команды размещались по четному адресу.
* Константы и метки. 

В следующем фрагменте кода приведена:

* именованная константа А (равная восьмеричному числу 123), 
* метка В, 
* восьмеричное число 15, 
* десятичное число 12, 
* символьная константа z (равна значению ascii кода символа z, т.е 122 десятичное или 172 восьмеричное). Одна одинарная кавычка *перед* символом.
```
        A = 123
        .=1000
B:      .WORD   15, 12., 'z, A, B     
```
этот фрагмент будет преобразован в следующие слова (вторая колонка, восьмеричные числа) по указанным адресам (первая колонка, восьмеричные числа). Третья колонка - объяснения.
```
001000  000015  восьмеричная константа 15 легла по адресу, указанному в .= как текущий
001002  000015  десятичное 12 есть 15 в восьмеричной системе
001004  000172  это ascii-код символа z
001006  000123  значение константы А
001010  001000  значение константы (метки) B
```

Заметим, что мы можем использовать В как именованную константу со значением 1000 (т.е. метка равна адресу, по которому она расположена). Область видимости метки - весь файл (как ниже, так и выше по тексту).
#### Чем отличаются директивы ассемблера от мнемоник команд

Обычная команда ассемблера с мнемоникой mov, например с аргументами `mov R1, R2` транслируется в команду ассемблера `010102`.

Псевдокоманды не транслируются в настоящие команды, они предназначены для удобства написания ассемблерного кода. 

* Директивы начинаются со знака `.` (точка).
* Директивы не являются мнемониками машинного кода , а управляют самим ассемблером или служат для размещения данных.
    * Управляющие директивы не создают машинного кода, но влияют на дальнейшее преобразование (например задают константы или новый адрес размещения машинного кода).
    * Директивы размещения данных предназначены для формирования в исполняемом коде данных, отличных от инструкций процессора.

# Постановка инженерной задачи
Дан код на ассемблере PDP-11. Его нужно скомпилировать и выполнить. Возможно выполнение в пошаговом режиме. При выполнении может быть выведена трассировка и показаны значения регистров и участков памяти. Так же показано содержимое stdout.
Проект может быть разбит на три модуля: эмулятор, компилятор и GUI. Эмулятор и компилятор - независимые модули. Возможно выполнение проекта без GUI с CLI. Возможна замена модуля компилятора эталонным компилятором as11.
В случае наличия в проекте всех трех модулей, студенты должны договориться о формате данных, которыми они обмениваются между модулями. Для разработки подзадач стоит воспользоваться эталонными эмулятором и компилятором, чтобы можно было на первых подзадачах работать независимо друг от друга.

## Эмулятор
### Подзадача 1

Эмулятор получает байт-код в формате, о котором договорятся в проекте. Если нет GUI, то исполняемый модуль дается в S-record формате (все числа шестнадцатеричные). Программа состоит из нескольких блоков. Каждый блок записан в формате:
```
адрес N
байт1
байт2
...
байтN
```
байт1 ... байтN должны быть размещены начиная с указанного адреса.
Код читается из указанного файла и загружается в память эмулятора.
Критерии успешности: в нужных участках памяти расположены верные данные; есть юниттесты для чтения и записии в байт и слово.
### Подзадача 2
Реализуется выполнение одной команды (в рамках цикла выполнения всей программы). Выполняется программа сложения двух чисел.
Критерии успешности: есть юниттесты на новые команды; в регистарах после работы программы верные значения; программа выполняет трассировку.
### Подзадача 3
Реализуется команда SOB.
Критерии успешности: работает итеграционный тест суммирования массива указанной длины.
### Подзадача 4
Реализация PSW, команд ветвления и команд работы с флагами.
Критерий успешности: работают интеграционные тесты суммирования массива слов до 0 и массива байт до 0.
### Подзадача 5
Реализация работы с внешними устройствами: монитором и клавиатурой. Допустима реализация, когда устройство всегда готово к работе.
Критерий успешности: работают интеграционные тесты, которые печатают Hello, world без функций
### Подзадача 6
Реализация команд JSR и RTS.
Критерий успешности: работа интеграционного теста с печатью Hello, world с помощью функций. Вычисление чисел Фиббоначи с помощью рекурсии (любой тест с рекурсивным вызовом функций).
### Подзадача 7
Реализация оставшихся команд. Создание юнит или интеграционных тестов для этих команд.
## Компилятор
### Подзадача 1
Разбирается структура программы. Вычленяются комментарии, метки, названия команд, аргументы. Разбирается псевдокоманда `.=`
### Подзадача 2
Разбор аргументов SS и DD для мод адресации, используемых в первом интеграционном тесте (сложение двух чисел).
### Подзадача 3
Разбор меток. Вычисление адресов меток.
Псевдокоманда ассемблера `.WORD` и `.BYTE`
### Подзадача 4
Вычисление адресов перехода по меткам, моды 6 по 7 регистру. Вычисление адресов перехода в операторах безусловного перехода и ветвлений.
### Подзадача 5
Псевдокоманды ассемблера для задания символов, строк, десятичных чисел.
### Подзадача 6
Прочие псевдокоманды ассемблера.
## IDE
### Подзадача 1
Показ листинга программы как содержимого памяти и ассемблерного кода.
### Подзадача 2
Показ трассировки при выполнении прогаммы.
### Подзадача 3
Показ содержимого регистров при выполнении прогаммы.
### Подзадача 4
Пошаговое выполнение программы в режиме отладки.
### Подзадача 5
Показ определенных участков памяти (адрес начала и размер указывает пользователь).
### Подзадача 6
Постановка breakpoint, выполнение программы до точки остановки.
### Подзадача 7
Редактирование ассемблерного кода и последующая компиляция.
# Спискок литературы
1. Проект http://pdp-11.org.ru/
2. https://stepik.org/course/65259 курс "Моя первая большая программа".
3. Фрэнк Т. PDP-11. Архитектура и программирование.
   https://www.ozon.ru/product/pdp-11-arhitektura-i-programmirovanie-frenk-tomas-831466005/
3. Остин Тодд, Таненбаум "Архитектура компьютера"
Артикул

935932651

Издательство

[Питер](https://www.ozon.ru/publisher/piter-856134/)

Серия

[Классика Computer Science](https://www.ozon.ru/series/klassika-computer-science-1065023/)

Год выпуска

2021

Язык издания

Русский

ISBN

978-5-4461-1103-9

# Глоссарий
little endian и big endian - способы записи слова из нескольких байт, когда байт с младшими разрядами записывается для little endian - по меньшему адресу, для big endian - по большему адресу.
Бит - 0 или 1.
Байт - 8 бит.
Слово - 16 бит.
Разрядность команды - сколько бит содержит команда.
Трассировка выполнения программы - печать во время выполнения программы выполняемых команд и их аргументов.
Эмулятор - это программа, которая создает для другой программы иллюзию, что она работает в привычной среде: получает данные в нужном формате, исполняет команды на правильной архитектуре и т. д.

