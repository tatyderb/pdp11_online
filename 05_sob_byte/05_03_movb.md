# Команды для работы с байтами

lesson = 706560

## Байтовые команды

Мы все время работали с числами, которые хранятся в словах и занимают 2 байта. Но не все числа такие большие. Часто мы работаем с небольшими числами, для которых хватит 1 байта. Память в PDP-11 экономили и поэтому много команд имеет похожие команды для работы с байтами. Например, команды mov и movb.

| Мнемоника | Опкод | NZVC | Описание | Замечания |
|----|----|----|----|----|
| **MOV** s, d | 01SSDD | `----` | `**0-` | d = s |
| **MOVB** s, d | 11SSDD | `----` | `**0-` | d = s |

Разница в опкоде в самом старшем бите. У битовых вариантов команд опкод начинается с 1, у вариантов для работы со словами опкод начинается с 0.

Поэтому в таблице такие "двойные" команды описывают так:

| Мнемоника | Опкод | NZVC | Описание | Замечания |
|----|----|----|----|----|
| **MOVb** s, d | B1SSDD | `----` | `**0-` | d = s |

где **B** - это или 0 для mov, или 1 для movb.

**Некоторые команды имеют единственный вариант, для слова**. Например, команда ADD.

## Суммирование массива из 4 байт.

[02_sob_byte](https://github.com/tatyderb/pdp11_tests/tree/master/02_sob_byte)

```
    . = 100                     ; данные располагаются с 100 адреса
A:  .BYTE 34, 12, -1, 66        ; массив (А - константа, равна адресу 100), сумма = 133, так как все числа восьмеричные
N:  .BYTE 4                     ; размер массива А

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Sum all data in the A array and store the summ into R0
;    R0 - sum
;    R1 - counter
;    R2 - address
;    R3 - (byte)*R2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;    
    .=1000                     ; код располагается с 1000 адреса
    mov #4, R1                 ; замените потом #4 на @#N и отладьте 3 моду
    mov #A, R2                 ; R2 - адрес начала массива
    clr R0                     ; R0 = 0
    
LOOP:
    movb (R2)+, R3             ; R3 = *R2; R2++ записывает в R3 число, лежащее по адресу, хранимому в R2, этот адрес увеличивается
    add R3, R0                 ; очередное число прибавляется к текущей сумме
    sob R1, LOOP               ; if (--R1 != 0) goto LOOP;
    
    halt
```

Изменения по сравнению с вариантом суммирования массива слов:

* Массив байт `.BYTE`, а не слов `.WORD`
```cpp
A:  .BYTE 34, 12, -1, 66
```
* так как нет байтового варианта add, то сначала **байт** из массива копируется в регистр R3 командой **movb**, далее R3 (слово) добавляется в R0 (слово) командой add.

## Байтовые команды и моды адресации

Рассмотрим перебор массива слов и массива байт. 

### Массив слов

Пусть адрес начала массива хранится в R2. 
```cpp
    .=100
A:  .WORD    34, 12, -1, 66
```
чтение числа по адресу, который хранится в R2 и переход к следующему адресу можно сделать так:
```cpp
mov #A, R2      ; в R2 записали константу 100, то есть адрес начала массива А
mov (R2), R3    ; число по адресу из регистра R2 записали в регистр R3
add #2, R2
```
или
```cpp
mov #A, R2      ; в R2 записали константу 100, то есть адрес начала массива А
mov (R2)+, R3   ; число по адресу из регистра R2 записали в регистр R3, R2 увеличился на 2
```

### Массив байт

Все то же самое, но А - это адрес начала массива байт.

```cpp
    .=100
A:  .BYTE    34, 12, -1, 66
```
чтение числа по адресу, который хранится в R2 и переход к следующему адресу можно сделать так:
```cpp
mov #A, R2      ; в R2 записали константу 100, то есть адрес начала массива А
mov (R2), R3    ; число по адресу из регистра R2 записали в регистр R3
add #1, R2
```
или
```cpp
mov #A, R2      ; в R2 записали константу 100, то есть адрес начала массива А
movb (R2)+, R3  ; число по адресу из регистра R2 записали в регистр R3, R2 увеличился на 1
```

Аналогично для моды 4 (автодекремент). `-(R2)`

То есть **для моды 2 и 4, если команда байтовая, то изменение происходит не на 2, а на 1. За исключением регистров 7 и 6. Для регистров 7 и 6 всегда изменяется на 2**.

Почему так сделано? R7 это PC, то есть адрес следующей команды, то есть адрес слова. Он обязан быть четным. Если мы сделаем `movb (PC)+, R0`, то PC станет нечетным и разбор программы сломается. Аналогично, мы потом узнаем, R6 тоже должен оставаться всегда четным.

Обратите внимание, что значение аргумента в случае байтовой команды movb - 1 байт, а в случае mov - 1 слово.

## Как реализовать?

* Объявите глобальную переменную, которая будет хранить, какая сейчас команда разбирается - байтовая или нет. Определить это можно по старшему биту в опкоде команды.
* Допишите 2 и 4 моду для битовых команд.
* Реализуйте команду `movb`. Как именно - решать вам, можно реализовать две функции, `do_mov()` и `do_movb()`, можно обойтись одной, внутри записав if по глобальной переменной.
* запустите тест суммирования для массива байт [https://github.com/tatyderb/pdp11_tests/tree/master/02_sob_byte](https://github.com/tatyderb/pdp11_tests/tree/master/02_sob_byte)

## Чтение и запись байта в регистр

Регистр 16 бит, байт 8 бит. Как происходит чтение и запись в регистр одного байта?

При **чтении** читает только младший байт регистра (биты 7-0). Значение старшего байта (биты 15-8) игнорируется.

```
|15            8|7             0| - номера бит
|?|?|?|?|?|?|?|?|1|0|0|0|0|0|1|1| - содержимое регистра, бинарные числа
| игнорируется  |2  |  0  |  3  | - содержимое бит, восьмеричные числа
```

При записи число тоже записывается в младший байт. Что происходит со старшим байтом и почему так сделано?

Рассмотрим пример на языке Си (C++, Java):
```cpp
char x = 3;
int y = x;
```
Ожидаем, что значение переменной `y` равно 3.

```cpp
char x = -3;
int y = x;
```
Ожидаем, что значение переменной `y` равно -3.

Хочется получить такое же поведение при записи байта в регистр. Если пишем байт со значением 3, то в регистре 3. Если байт содержит -3, то весь регистр будет равен -3.

Посмотрим, что должно быть записано в старшем байте, чтобы получить такое поведение.

Число 3:
```
|15            8|7             0| - номера бит
                |0|0|0|0|0|0|1|1| - число 3 (байт)
|0|0|0|0|0|0|0|0|0|0|0|0|0|0|1|1| - число 3 (слово)
```
Число -3:
```
|15            8|7             0| - номера бит
                |1|1|1|1|1|1|0|1| - число -3 (байт)
|1|1|1|1|1|1|1|1|1|1|1|1|1|1|0|1| - число -3 (слово)
```
Весь старший бит заполнен или всеми 0, или всеми 1, в зависимости от значения бита номер 7 (знакового бита в младшем байте). То есть знаковый бит младшего байта расширяется на весь старший байт, происходит **знаковое расширение**.

Подумайте, где *в одном месте* можно реализовать байтовое расширение при записи байта в регистр. Это точно НЕ функция `do_mov` или `do_movb`, за такой костыль буду снижать оценку!