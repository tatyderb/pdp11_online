# sob

lesson = 706559

## sob - substruct one and branch

Команда **sob r метка**, например `sob R2 LOOP`

* уменьшает значение регистра на 1 (в примере число в регистре R2 уменьшается на 1, в регистре теперь новое значение).
* если полученное число >0, то управление передается на метку.

Команда используется для организации цикла из N повторений. Рассмотрим пример для суммирования массива из 4 элементов.

## Пример

Рассмотрим [программу](https://github.com/tatyderb/pdp11_tests/tree/master/02_sob), которая суммирует 4 элемента массива А.

Используются регистры:

* R0 - в нем накапливается сумма, сначала 0
* R1 - сколько итераций цикла осталось выполнить, сначала 4.
* R2 - адрес очередного элемента массива А, сначала равен адресу начала массива, то есть 100.
* R3 - значение очередного суммируемого элемента, то есть по очереди числа 34, 12, -1, 66

Можно обойтись без использования регистра R3 и вместо
```cpp
mov (R2)+, R3             ; R3 = *R2; R2++ записывает в R3 число, лежащее по адресу, хранимому в R2, этот адрес увеличивается
add R3, R0                 ; очередное число прибавляется к текущей сумме
```
писать сразу
```cpp
add (R2)+, R0               ; число по адресу R2 прибавляется к сумме в R0, адрес, который хранится в R2, увеличивается на 2
```
но у нас следующим шагом - изучение работы с байтами, поэтому будем писать длинный код, который потом проще будет модифицировать.
```
    . = 100                     ; данные располагаются с 100 адреса
A:  .WORD 34, 12, -1, 66        ; массив (А - константа, равна адресу 100), сумма = 133, так как все числа восьмеричные
N:  .WORD 4                     ; размер массива А

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Sum all data in the A array and store the summ into R0
;    R0 - sum
;    R1 - counter
;    R2 - address
;    R3 - (byte)*R2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;    
    .=1000                     ; код располагается с 1000 адреса
    mov #4, R1                 ; замените потом #4 на @#N и отладьте 3 моду
    mov #A, R2                 ; R2 - адрес начала массива
    clr R0                     ; R0 = 0
    
LOOP:
    mov (R2)+, R3             ; R3 = *R2; R2++ записывает в R3 число, лежащее по адресу, хранимому в R2, этот адрес увеличивается
    add R3, R0                 ; очередное число прибавляется к текущей сумме
    sob R1, LOOP               ; if (--R1 != 0) goto LOOP;
    
    halt
```

В R1 лежит число 4 - сколько итераций цикла осталось выполнить.

`sob R1, LOOP` - Из содержимого регистра R1 отнимается 1 и записывается в R1. Если в R1 не ноль, то управление передается на метку LOOP (следующая команда выполняется по адресу LOOP).

Если бы у нас в языке Си была переменная R1 и стояла метка LOOP, то `sob R1, LOOP` эквивалентно коду
```cpp
if (--R1 != 0)
    goto LOOP;
```

Подумайте, как в эмуляторе сделать так, чтобы следующая команда читалась и разбиралась по адресу 01012.

### Трассировка этого кода

```cpp
---------------- running --------------
001000: mov     #000004,r1              [001002]=000004 
001004: mov     #000100,r2              [001006]=000100 
001010: clr     r0                      
001012: mov     (r2)+,r3                [000100]=000034 
001014: add     r3,r0                   R3=000034 R0=000034 
001016: sob     r1,001012               
001012: mov     (r2)+,r3                [000102]=000012 
001014: add     r3,r0                   R3=000012 R0=000046 
001016: sob     r1,001012               
001012: mov     (r2)+,r3                [000104]=177777 
001014: add     r3,r0                   R3=177777 R0=000045 
001016: sob     r1,001012               
001012: mov     (r2)+,r3                [000106]=000066 
001014: add     r3,r0                   R3=000066 R0=000133 
001016: sob     r1,001012               
001020: halt                            

---------------- halted ---------------
r0=000133 r2=000110 r4=000000 sp=000000
r1=000000 r3=000066 r5=000000 pc=001022
psw=000000: cm=k pm=k pri=0        [16]
```

## Реализация SOB

В [таблице команд](https://stepik.org/lesson/347539/step/1) посмотрим какой опкод и какие аргументы у команды SOB

| Мнемоника | Опкод | NZVC | Описание | Замечания |
|----|----|----|----|----|
| **SOB** r, a | 077RNN | `----` | Subtract One and Branch | PC=PC-2*NN |

* `077` - код операции, 7 бит (это 16 - (3+6))
* R - номер регистра, 3 бита
* NN - сдвиг, 6 бит, беззнаковое (положительное) число

Разберемся, что такое NN и как реализуется переход по адресу `a`.

Код:
```cpp
LOOP:
    mov (R2)+, R3             ; R3 = *R2; R2++ записывает в R3 число, лежащее по адресу, хранимому в R2, этот адрес увеличивается
    add R3, R0                 ; очередное число прибавляется к текущей сумме
    sob R1, LOOP               ; if (--R1 != 0) goto LOOP;
```
Листинг этого кода:
```cpp
001012:		LOOP:
001012:		    mov (R2)+, R3             ; R3 = *R2; R2++ записывает в R3 число, лежащее по адресу, хранимому в R2, этот адрес увеличивается
	 012203
001014:		    add R3, R0                 ; очередное число прибавляется к текущей сумме
	 060300
001016:		    sob R1, LOOP               ; if (--R1 != 0) goto LOOP;
	 077103
001020:
```
То есть метка LOOP имеет значение 1012, `sob R1, LOOP` кодируется в 077103.

* 077 - код операции,
* 1 - номер регистра, R1
* 03 - это NN. Посмотрим, как оно связано с меткой LOOP.

Адрес - это 16-битное число. Если мы будем хранить адрес перехода, то в 16 бит и опкод команды, и номер регистра, и адрес перехода не поместится. SOB создавался как команда для цикла, в цикле нужно переходить назад по адресам и переходить недалеко.

Когда мы разбираем команду sob, которая расположена по адресу 1016, pc уже равно 1020 (адресу следующего слова).

Нужно перейти на адрес 1012. То есть выполнить `pc = 1012`, то есть, учитывая текущее значение pc, это `pc = pc - 6`, то есть 1020 - 6 = 1012. В NN хранится смещение, поэтому в SOB мы можем только возвращаться на метку с меньшим адресом и недалеко.

Адрес команды sob - четный, адрес метки - тоже четный. Смещение всегда будет **четное** количество байт (у нас 6), то есть в бинарном виде всегда оканчиваться 0. Из 6 бит на смещение 1 бит будет всегда хранить 0. Это не экономно. Поэтому в NN записывают смещение без последнего 0 (или смещение на количество слов, а не байт). Теперь в NN можно записать число в 2 раза больше. Формула для вычисления адреса перехода $$pc = pc - 2 \cdot NN$$.


## Реализация SOB

* Реализуйте функцию SOB в вашем эмуляторе. 
* Убедитесь, что тест [https://github.com/tatyderb/pdp11_tests/tree/master/02_sob](https://github.com/tatyderb/pdp11_tests/tree/master/02_sob) работает правильно и сумма получается 133.
* Возьмите следующий тест, где используется 3 мода. [https://github.com/tatyderb/pdp11_tests/tree/master/02_sob_mode3](https://github.com/tatyderb/pdp11_tests/tree/master/02_sob_mode3)