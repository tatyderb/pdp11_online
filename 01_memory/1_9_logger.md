# Логирование

lesson = 874723
lang = c

## Что такое логирование

Как находить ошибки в больших программах? 

* **Конкретизировать ошибку**. Не "ничего не работает" или "какая-то ошибка в функциях работы с памятью", а "при записи в нечетный байт значение байта не изменяется" или "значение в байте до записи влияет на результат записи в байт". Написать минимальный тест, который воспроизводит ситуацию.

* Смотреть пристально на код и думать, как могла возникнуть эта ситуация (**метод пристального взгляда**). *Знать бы куда именно смотреть, если ваш проект очень большой*.

* **Проходить код в дебагере**, расставляя точки остановки (breakpoints), заходить в функции, смотреть на значения переменных. Это нужно уметь делать. Поэтому мы рекомендуем вам отлаживаться в IDE с возможность запускать функцию под отладчиком (в дебагере). Если не работает интеграционный тест, который считает числа Фибоначчи рекурсивным методом, то путь до ошибки может занимать много времени. Не всегда можно запустить код под отладчиком, если ошибка появляется только на продуктовом сервере (банковское приложение с реальными деньгами, вряд ли вы будете в восторге, если ваш банк закроется на "мы отлаживаем программу" или ваши деньги исчезли, "потому что мы отлаживались во время зачисления вам денег".

* **Отладочная печать**. Печатаем нужные данные при выполнении кода.  Анализ напечатанного позволяет находить ошибки. 

Принято, чтобы при работе программы, особенно постоянно работающие серверы, писали информацию о своей работе в файл. Это лог или лог файл. Не путать с save-файлами в игре. В save-файле одномоментный слепок состояния, который можно восстановить (загрузить). Лог - это дневник, который ведет программа. Что ее попросили делать, как она это делала. Где-то подробно, где-то не очень. По логу можно попробовать анализировать поведение системы, если произошла ошибка. Ошибка была ночью на сервере, утром разработчики пытаются понять, что *конкретно* сработало не так.

При работе с логами важно уметь настраивать и быстро изменять что именно будет выводить программа. Возможно, увеличивая количество отладочной печати только в одном месте и потом быстро убирать код, который производит эти сообщения. Плохо - это писать `printf`, а потом закомментировать их вызов (или вообще удалять этот код). Хочется, не выбирать `printf` в коде, как изюм в булке, а в одном месте изменять количество отладочной печати во всей программе. 

Для этого используют логеры (logger) - специальные библиотеки, которые написаны в современных языках программирования и часто входят в стандартную установку для разработке на языке. Но язык Си достаточно старый язык, используется для написания компактных программ, поэтому "стандартного логера" в нем нет.

С другой стороны, нам не нужна большая и гибкая система логирования. Достаточно, чтобы работала базовая функциональность. Поэтому, если вы пишете проект на других языках, вы сами ищете информацию, как использовать логер в простейшем случае. А мы на следующих шагах сделаем простейший логер на языке Си.

## Требования к функции логирования

Общий принцип логирования - это вызов функций логирования с указанием **уровня логирования**.

Уровни логирования могут быть такие:

* error (ошибка) - сообщение об ошибке, его всегда стоит выводить.
* warning (предупреждение) - вы сами видели, как сообщения об ошибках помогают найти ошибку в коде еще на этапе компиляции, и как они раздражают, эти бесконечные unused variable, когда не весь код дописан.
* info (информация) - обычно пишут, что за программа, когда она запущена и так далее.
* debug (отладочная печать)

Иногда вам не хватает отладочной печати и хочется сделать `more_debug` и `more_more_debug`. 

То есть при выполнении кода при установленном уровне логирования INFO, выводились сообщения этого уровня или больше (INFO, WARNING, ERROR), но не выводились сообщения с уровнем DEBUG:
```cpp
log_level = INFO;
log(ERROR, "Для карты 123456789 введен неверный пин-код");
log(INFO, "В систему зашел пользователь с именем Alex");
log(DEBUG, "Это отладочная печать");
log(WARNING, "Пользователь Alex пытается снять 1000 рублей, на счету 347 рублей");
```
напечатает:
```cpp
Для карты 123456789 введен неверный пин-код
В систему зашел пользователь с именем Alex
Пользователь Alex пытается снять 1000 рублей, на счету 347 рублей
```
Отладочная печать не выводится.

Для логирования нам нужно:

* определить уровни логирования - константы в коде через `#define` или `enum` или любым другим способом.
* log_level - переменную, в которую записан пороговый уровень логирования (в примере выше это INFO).
* `log(level, message)` - функция логирования, в которой указан уровень логирования `level` и сообщение, которое нужно вывести, если этот уровень больше и равен установленному пороговому уровню логирования `log_level`.
* `set_log_level(level)` - функция, которая устанавливает пороговый уровень логирования как `level` и возвращает старый пороговый уровень логирования (удобно, если мы перед каким-то участком, который хотим отладить устанавливаем уровень DEBUG, а потом восстанавливаем прежний уровень логирования):
```cpp
set_log_level(WARNING);
log(ERROR, "Ошибка 1");             // Ошибка 1
log(INFO, "Информация 2");          // не напечатает ничего
old_log = set_log_level(DEBUG);     // old_log = WARNING
log(INFO, "Информация 3");          // Информация 3
log(DEBUG, "Отладка 4");            // Отладка 4
set_log_level(old_log);             // восстановили прежний пороговый уровень
log(DEBUG, "Отладка 5");            // не напечатает ничего
log(WARNING, "Предупреждение 6");   // Предупреждение 6
```

В эмуляторе по мере выполнения программы на ассемблере PDP-11 мы будем печатать *трассировку* - информацию о том, что именно сейчас выполняется. Это поможет вам находить, где именно программа начала работать неверно. Поэтому к уровням логирования стоит добавить **TRACE** - между DEBUG и INFO.

Можно, если вы ходите, сделать по одной функции на каждый уровень логирования. Так, чтобы эти два вызова работали одинаково:
```cpp
log(INFO, "Какой-то текст");
info("Какой-то текст");
```
Делать или нет функции-обертки error, warning, info, trace, debug - на ваше усмотрение.

**Не нужно в эмуляторе использовать `printf`, `fprintf`, используйте вместо них написанную вами функцию логирования.**

## TASKINLINE Реализация функции логирования на языке Си

* Определите константы - уровни логирования, можно через `#define` или [enum](https://stepik.org/lesson/666768/step/1)
    * ERROR
    * INFO
    * TRACE
    * DEBUG
    * можно еще по вашему желанию
* Объявите, если нужно, переменные.
* Реализуйте функцию `log(level, format, ...)` с [переменным числом аргументов](https://stepik.org/lesson/311877/step/1)
* Реализуйте функцию `set_log_level(level)`, которая устанавливает пороговый уровень логирования и возвращает предыдущий уровень логирования.
* Пошлите написанный код. Функция main уже определена, ее посылать не нужно.

FOOTER

int main()
{
    set_log_level(INFO);
    
    int x, y;
    scanf("%d%d", &x, &y);
    
    log(INFO, "%d + %d = %d\n", x, y, x + y - 1);
    log(ERROR, "Oops, %d+%d=%d, not %d\n", x, y, x + y, x + y - 1);
    log(TRACE, "Эту надпись не должны видеть\n");
    
    int old_log_level = set_log_level(TRACE);
    
    log(TRACE, "Visible text\n");
    log(DEBUG, "Debug info\n");
    
    set_log_level(old_log_level);
    
    log(INFO, "The end!\n");
    log(TRACE, "No code after return\n");
    
    return 0;
}
TEST
2 3
----
2 + 3 = 4
Oops, 2+3=5, not 4
Visible text
The end!
====

## git

Если вы написали функцию логирования, то 

* Замените все `printf` и `fprintf` на эту функцию.
* Проверьте, что код работает.
* git commit, git push.
