# Проверка функций работы с памятью

lesson = 312216
lang = c

## SKIP VIDEO

https://youtu.be/NzTzw8BmfvI

## Загружаем программу в память PDP-11

Следующий шаг - загрузить программу в память PDP-11. Потом мы будем ее исполнять. Эти программы можно взять в виде тестов или написать самим и скомпилировать их (об этом тоже в следующем уроке).

## TASKINLINE load_data() и mem_dump()

Формат файла программы (S-record file) описывает какие данные по каким адресам нужно записать.

Напишем функцию `load_data()`, которая считывает данные по описанному формату и записывает их в массив `mem`. Для проверки напишем функцию, которая печатает часть массива `mem`, назовем ее `mem_dump()`

1. Скопируйте свой код из предыдущей задачи.
1. Реализуйте функцию `void load_data()`, которая считывает данные по формату:
    * **Все числа шестнадцатеричные.**
    * Файл состоит из 1 или более блоков.
    * Блок начинается со строки где через пробел записаны **адрес начала блока** и N **сколько байт в этом блоке**.
    * далее идут N строк, по 1 байту на строку.
1. Реализуйте функцию `void mem_dump(address adr, int size)`, которая печатает `size` байт, начиная с адреса `adr` в виде слов по формату `"%06o: %06o %04x"`:
```cpp
адрес: восьмеричное_слово шестнадцатеричное_слово
```
Заметим, что восьмеричное число 01000 это шестнадцатеричное число 0x200. 

Структура блока **входных данных** (таких блоков может быть несколько):
```
адрес_начала_блока N
байт1
байт2
...
байтN
```
Пример файла:
```cpp
0200 000a
c0
65
7a
00
3f
10
f8
01
00
00
0400 0002
76
0f
```

Не забудьте в программе вызвать `mem_dump`, чтобы напечатать 20 байт, начиная с адреса 0x40 и 0x26 байт, начиная с адреса 0x200. Тесты сделаны под такой код:
```cpp
int main()
{
    load_data();
    
    mem_dump(0x40, 20);
    printf("\n");
    mem_dump(0x200, 0x26);
    
    return 0;
}
``` 

**Не забудьте после отладки кода сделать commit в репозиторий. Не забудьте про push, если репозиторий удаленный, например, на github**.

TEST
0040 000c
1c
0a
05
36
1c
00
0a
00
05
00
36
00
0200 000c
c0
15
02
00
c1
15
03
00
01
60
00
00
----
000100: 005034 0a1c
000102: 033005 3605
000104: 000034 001c
000106: 000012 000a
000110: 000005 0005
000112: 000066 0036
000114: 000000 0000
000116: 000000 0000
000120: 000000 0000
000122: 000000 0000

001000: 012700 15c0
001002: 000002 0002
001004: 012701 15c1
001006: 000003 0003
001010: 060001 6001
001012: 000000 0000
001014: 000000 0000
001016: 000000 0000
001020: 000000 0000
001022: 000000 0000
001024: 000000 0000
001026: 000000 0000
001030: 000000 0000
001032: 000000 0000
001034: 000000 0000
001036: 000000 0000
001040: 000000 0000
001042: 000000 0000
001044: 000000 0000
====
0040 000c
1c
0a
05
36
1c
00
0a
00
05
00
36
00
0200 0026
c0
15
40
00
10
94
02
92
c1
15
40
00
c1
65
02
00
43
92
c0
15
44
00
10
14
04
12
c1
15
44
00
c1
65
02
00
45
12
00
00
----
000100: 005034 0a1c
000102: 033005 3605
000104: 000034 001c
000106: 000012 000a
000110: 000005 0005
000112: 000066 0036
000114: 000000 0000
000116: 000000 0000
000120: 000000 0000
000122: 000000 0000

001000: 012700 15c0
001002: 000100 0040
001004: 112020 9410
001006: 111002 9202
001010: 012701 15c1
001012: 000100 0040
001014: 062701 65c1
001016: 000002 0002
001020: 111103 9243
001022: 012700 15c0
001024: 000104 0044
001026: 012020 1410
001030: 011004 1204
001032: 012701 15c1
001034: 000104 0044
001036: 062701 65c1
001040: 000002 0002
001042: 011105 1245
001044: 000000 0000
====
0040 0004
1c
0a
ff
36
0200 0012
c1
15
04
00
c2
15
40
00
00
0a
83
92
c0
60
82
0a
44
7e
-----
000100: 005034 0a1c
000102: 033377 36ff
000104: 000000 0000
000106: 000000 0000
000110: 000000 0000
000112: 000000 0000
000114: 000000 0000
000116: 000000 0000
000120: 000000 0000
000122: 000000 0000

001000: 012701 15c1
001002: 000004 0004
001004: 012702 15c2
001006: 000100 0040
001010: 005000 0a00
001012: 111203 9283
001014: 060300 60c0
001016: 005202 0a82
001020: 077104 7e44
001022: 000000 0000
001024: 000000 0000
001026: 000000 0000
001030: 000000 0000
001032: 000000 0000
001034: 000000 0000
001036: 000000 0000
001040: 000000 0000
001042: 000000 0000
001044: 000000 0000
====
0200 0012
c1
15
04
00
c2
15
40
00
00
0a
83
92
c0
60
82
0a
44
7e
----
000100: 000000 0000
000102: 000000 0000
000104: 000000 0000
000106: 000000 0000
000110: 000000 0000
000112: 000000 0000
000114: 000000 0000
000116: 000000 0000
000120: 000000 0000
000122: 000000 0000

001000: 012701 15c1
001002: 000004 0004
001004: 012702 15c2
001006: 000100 0040
001010: 005000 0a00
001012: 111203 9283
001014: 060300 60c0
001016: 005202 0a82
001020: 077104 7e44
001022: 000000 0000
001024: 000000 0000
001026: 000000 0000
001030: 000000 0000
001032: 000000 0000
001034: 000000 0000
001036: 000000 0000
001040: 000000 0000
001042: 000000 0000
001044: 000000 0000
====
0040 0004
1c
0a
ff
36
0200 0012
c1
15
04
00
c2
15
40
00
00
0a
83
92
c0
60
82
0a
44
7e
0050 0004
1c
0a
ff
36
----
000100: 005034 0a1c
000102: 033377 36ff
000104: 000000 0000
000106: 000000 0000
000110: 000000 0000
000112: 000000 0000
000114: 000000 0000
000116: 000000 0000
000120: 005034 0a1c
000122: 033377 36ff

001000: 012701 15c1
001002: 000004 0004
001004: 012702 15c2
001006: 000100 0040
001010: 005000 0a00
001012: 111203 9283
001014: 060300 60c0
001016: 005202 0a82
001020: 077104 7e44
001022: 000000 0000
001024: 000000 0000
001026: 000000 0000
001030: 000000 0000
001032: 000000 0000
001034: 000000 0000
001036: 000000 0000
001040: 000000 0000
001042: 000000 0000
001044: 000000 0000
====

## Чтение данных из файла

Мы читали данные из стандартного потока ввода **stdin**, пора читать данные из файла. Сделайте файл `data.txt` в той же директории, где лежит исполняемый модуль.

Напишите функцию `void load_file(const char * filename)`, которая читает данные из файла с именем `filename`.

Отладьте ее для вызова из функции `main` кода
```cpp
load_file("data.txt");
```
Не забудьте [проверять](https://stepik.org/lesson/266213/step/1), что файл открылся. Если при открытии файла возникли проблемы, пишите диагностику с помощью стандартной функции **perror** и завершайте программу.

git commit, git push. Это достойный кусок кода для коммита, потому что вы дописали (почти) законченный кусок новой функциональности.

## Аргументы командной строки

Вопрос: как задавать имя файла, откуда будем читать данные?

### Ужас-ужас

Rопировать данные из файла на вход при запуске. За весь проект это займет у вас много времени. Не эффективно.

### Очень неправильно

Читать путь к файлу из stdin:
```cpp
char path[1000];
printf("Введите путь к файлу с данными: ");
// тут будем читать
``` 
Почему очень неправильно? Во-первых, неудобно все время вводить путь к файлу, особенно, если он длинный. Во-вторых, трудности или ошибки при чтении.

Если читать `scanf("%s", path)`, то если путь содержит пробел, то или экранировать при вводе, или получим ошибку.

Если читать `fgets(path, stdin)`, то прочитаем вместе с `\n` или для нелинуксовых терминалов `\r\n` в конце строки, которые нужно убрать. В пути нет никаких `\n`.

### Не использовать имена файлов

А, как и раньше, в командной строке [перенаправлять данные](https://stepik.org/lesson/265319/step/1) на stdin при запуске программы. Это работает не зависимо от языка программирования:
```cpp
./pdp.exe < data.txt
```
Этим подходам грешат пользователи IDE, которые не умеют настроить систему.

### Передавать путь к файлу в аргументах командной строки

Самый правильный способ. Тем более, вам скоро добавлять ключ для вывода трассировки или запуска автотестов. Гораздо приятнее в командной строке написать:
```cpp
./pdp.exe -t data.txt
```

Читаем про [аргументы командной строки](https://stepik.org/lesson/311876/step/1), если забыли.

**Задача**: 

1. получать путь к файлу с данными в аргументах командной строки.
2. если имя файла не задано, то или читайте данные с stdin, или выводите справку по вашей программе (как ее запускать). На ваше усмотрение.
3. git commit, git push.

## Удобная загрузка программ

Большую долю времени написания проекта будет занимать тестирование кода и его отладка. Поэтому нужно сделать так, чтобы запускать тест и переключаться с одного теста на другой было быстро и удобно.

* Будем писать юнит-тесты, наподобие тех, что мы сделали для тестирования функций чтения и записи. Не уничтожайте их. Их надо будет прогонять все после реализации очередной фичи, чтобы убедиться, что мы не сломали уже работающий код. Надеюсь, к концу проекта вы убедитесь, что быстрее придумать и написать несколько небольших юнит-тестов, чем отлаживаться на большом интеграционном тесте.
* Тесты, которые "настоящая программа на ассемблере PDP-11" - интеграционные, так как они проверяют всю систему целиком. Подумаем, как удобно и быстро запускать такие тесты.

У нас уже есть функция `load_data`, которая читает данные из стандартного потока ввода stdin. Можно запускать тесты для вашей программы `pdp11.exe` так:
```cpp
./pdp11.exe < путь_к_директории_с_тестами/тест
```
Удобно репозиторий с тестами положить так, чтобы путь к тестам было легко набирать. Например, в UNIX терминале в директории с файлом `pdp11.exe` сделать символическую ссылку на директорию с тестами `test`, тогда путь будет короткий. Можно в эту директорию склонировать репозиторий с тестами. В любом случае в директориях с вашим кодом возникнут чужие файлы. Стоит сделать так, чтобы они, как и исполняемый файл `pdp11.exe`, и директория `test` не была добавлена в репозиторий.

* В корне вашего репозитория должен быть файл с именем `.gitignore`, если его нет, создайте в том же редакторе, где пишете код, или в любом другом текстовом редакторе. У файла нет расширения.
* в этот файл напишите имена всех файлов и директорий, которые не нужно коммитить. Например:
```cpp
test
*.exe
*.o
debug/*.exe
```
У этого файла простой синтаксис. Пишем имя директории или файла, можно использовать `*` как подстановку *любой*.

### Задача 

1. скачайте репозиторий с тестами [https://github.com/tatyderb/pdp11_tests](https://github.com/tatyderb/pdp11_tests) можете склонировать его в текущую директорию в директорию `test` командой
```cpp
git clone git@github.com:tatyderb/pdp11_tests.git test
```
2. Добавьте файл `.gitignore` в ваш проект, если его еще нет. Перечислите в нем все файлы и директории, которые стоит игнорировать. Это все файлы, которые получаются при сборке (`*.exe`, `*.obj` и так далее). Кроме того, конфигурационные файлы IDE тоже не нужно класть в репозиторий. 
3. git add, git commit, git push.



