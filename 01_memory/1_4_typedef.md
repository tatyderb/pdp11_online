# Моделируем память и работу с ней, API функций чтения и записи

lesson = 312213
lang = c

## SKIP VIDEO 

https://youtu.be/QYrjDhg4dPA

## Побитовые операции

Для работы нам понадобится вспомнить [побитовые операции](https://stepik.org/lesson/305205/step/1). 

| Оператор | Что значит |
|----|----|
| `&` | Побитовое И |
| `|` | Побитовое ИЛИ |
| `^` | Побитовое XOR (исключающее или) |
| `~` | Побитовое отрицание |
| `>>` | побитовый сдвиг вправо |
| `<<` | побитовый сдвиг влево |

Этот проект делается в рамках курса по Архитектуре компьютера. Пожалуйста, используйте побитовые операции. Оставьте умножение, деление и остаток от деления курсу вычислительной математики.

## Шаг 1. Определяем типы

В первую очередь стоит определить типы для работы с байтом и словом. Если мы ошибемся с выбором удобного типа, то ближе к концу проекта нам придется вносить много правок в код. Удобнее, если в проекте определен и везде используется псевдоним к уже существующему типу. Тогда исправление типа сведется к правке единственной строки кода.

Так можно определить еще один псевдоним:
```cpp
typedef старый_тип новый_псевдоним; 
``` 
Например,
```cpp
typedef unsigned int Length;
```
Можно определять переменную и аргументы функций как `Length`, можно как `unsigned int`:
```cpp
Length x = 100;
unsigned int res;
res = x + 5;      // x и res фактически одного и того же типа
```
Определим типы **byte** (байт), **word** (слово), **address** (адрес байта или слова).

Типы должны быть подходящего размера, чтобы вместить байт и слово PDP-11. Можно взять тип большего размера, но не меньшего. Так же нужно решить, будет тип знаковым или беззнаковым (unsigned).

Что такое адрес байта/слова в эмуляторе? Это не привычный нам тип вида `char *`. Память PDP-11 - это массив в нашем эмуляторе, а адрес байта в памяти PDP-11, соотвественно, номер ячейки в этом массиве.

Размер памяти в PDP-11 был 64 килобайта, то есть нам нужно $64*2^{10} = 2^6 * 2^{10} = 2^{16}$ разных адресов. То есть для хранения любого адреса хватит 16 бит. В слове тоже содержится 16 бит, поэтому можно определить тип `address` как псевдоним типа `word`:
```cpp
typedef word address;    // адрес для 64 Кб
```

Если вы знаете про типы данных точной размерности, например, `int16_t`, то можете использовать их, но тогда рекомендуем сразу же определить макросы для печати байта и слова через соответствующие макросы формата `PRId16`.

Мы предполагаем, что вы используете тип без указания его точной размерности, например, `char`, `short`, `int` и тп.

То есть тип "байт" можно определить как `char`, или `unsigned char` или сделать его больше - любой целочисленный тип, знаковый или беззнаковый.

Задание: **напишите в своем файлы typedef для типов byte, word, address**.

## Шаг 2. Объявляем массив mem - "память" компьютера PDP-11

Объявим массив **mem** - память компьютера PDP-11. Она должна вмещать 64 килобайта. Определим макрос `MEMSIZE`, чтобы записать "64 килобайта" разных адресов:
```cpp
#define MEMSIZE (64*1024)   // размер памяти 64 килобайта
```
Забегая вперед скажем, что последние 8 байт памяти - специальное место для взаимодействия с внешними устройствами и для эмуляции памяти, в которых будут размещаться данные, достаточно 64-8=56 килобайт памяти.

Объявить массив можно двумя способами. Во-первых, можно объявить массив байт. Адрес `i` - индекс в массиве `mem`, значение по этому адресу `mem[i]`.
```cpp
byte mem[MEMSIZE];          // память
```
![mem_byte.png](https://stepik.org/media/attachments/lesson/312212/mem_byte.png)

В этом случае один байт занимает одну ячейку массива, а одно слово располагается в двух ячейках массива.

Второй вариант - определить массив из слов. Слова читать и писать только по четным адресам, байты - в первый или второй байт соответствующего слова. То есть `mem[i]` - слово по адресу `i`, состоит из двух байт по адресам `i` и `i+1`. Нечетные ячейки массива не используются.

```cpp
word mem[MEMSIZE];          // память
```

![mem_word.png](https://stepik.org/media/attachments/lesson/312212/mem_word.png)

Одна ячейка - одно слово, один байт - половина ячейки.

Оба варианта почти одинаковы по сложности реализации. Увеличение размера на 64 килобайта, занятого вашей программой, в современных компьютерах - мизерная разница. Ей можно пренебречь. Поэтому советуем не использовать "сжатое" хранение слов, где слова PDP-11 хранятся в каждой ячейке массива и делается пересчет адреса в индекс массива и обратно. Здесь легко ошибиться и рекомендуется пожертвовать 64 килобайт памяти ради упрощения кода и его отладки. Прошли те времена, когда самым дорогим в разработке было железо. Сейчас дороже всего - время разработчиков.

Задание: **определите переменную `mem` нужного размера**.

Где определять этот массив? Можно определить это в функции `main` и передавать в качестве аргумента в различные функции. Это будет зашумлять код. Рекомендуем определить переменную вне функций, чтобы любая функция чтения и записи в память могла к нему обратиться. Подумайте, нужно ли сделать массив глобальным или определить его как `static` с областью видимости в одном файле.

## Шаг 3. API для работы с памятью

Определим специальные функции чтения и записи байта и слова в эту память (массив `mem`):

* `void b_write (address adr, byte val)` - пишем значение (байт) `val` по адресу `adr`;
* `byte b_read (address adr)` - читаем байт по адресу `adr` и возвращаем его;
* `void w_write (address adr, word val)` - пишем значение (слово) `val` по адресу `adr`;
* `word w_read (address adr)` - читаем слово по адресу `adr` и возвращаем его;

## Шаг 4. Пишем тесты

До реализации фукнций напишем, как мы их будем использовать. Напишем тесты. Тесты на одиночные функции называются юниттестами (unit test).

Сначала сделаем простейшие тесты:

* записать байт, прочитать этот байт.
* записать слово, прочитать это слово.

Ожидаем, что прочитаем ровно то, что записывали. Давайте подумаем, какие баги в реализации функций **не ловят** эти тесты.

* Запись и/или чтение идет не в little-endian.
* Рассинхронизирована индексация (неправильно считается номер ячейки и куда писать) при работе с байтами и словами.
* Запись одного байта затирает другой байт. Аналогично со словом.

Список можно продолжать (если сумеете ошибиться другим способом - пишите в комментариях). Придумаем простой тест.

* Записать слово, прочитать из него оба байта. Симметричный тест с записью байт и чтением слова. Так мы проверим рассинхронизацию индексов, что у нас little-endian, и что запись одного байта не затирает другой.

Принципы написания тестов:

* у каждого теста печатаем заголовок, чтобы в отладочной печати отличать один тест от другого.
* печать данных теста, так как тест может упасть, выводим ее на небуферизованный поток сообщений об ошибках `stderr`.
* каждый тест комментируем.
* тесты пишем так, чтобы использовалась автоматическая проверка через `assert`, не заставляйте себя глазами проверять правильность отладочной печати при каждом прогоне тестов, переложите это на assert. Для его работы нужно подключить `assert.h`
* стараемся написать тесты так, чтобы покрыть большинство возможных ошибок.
* тесты выделяем в отдельную функцию и запускаем ее при каждом запуске программы. Это спасет нас, когда мы дописывая новую функциональность, поломаем старую (без тестов мы это можем не найти или решить, что проблема в другом месте).
* стараемся, чтобы результаты одного теста не влияли на другой тест (не сделали его ложноположительным)

```cpp
void test_mem()
{
    address a;
    byte b0, b1, bres;
    word w, wres;
    
    // пишем байт, читаем байт
    fprintf(stderr, "Пишем и читаем байт по четному адресу\n");
    a = 0;
    b0 = 0x12;
    b_write(a, b0);
    bres = b_read(a);
    // тут полезно написать отладочную печать a, b0, bres
    fprintf(stderr, "a=%06o b0=%hhx bres=%hhx\n", a, b0, bres);
    assert(b0 == bres);
    // аналогично стоит проверить чтение и запись по нечетному адресу
    
    // пишем слово, читаем слово
    fprintf(stderr, "Пишем и читаем слово\n");
    a = 2;        // другой адрес
    w = x3456;
    w_write(a, w);
    wres = w_read(a);
    // тут полезно написать отладочную печать a, w, wres
    fprintf(stderr, "a=%06o w=%04x wres=%04x\n", a, w, wres);
    assert(w == wres);
    
    // пишем 2 байта, читаем 1 слово
    fprintf(stderr, "Пишем 2 байта, читаем слово\n");
    a = 4;        // другой адрес
    w = 0xa1b2;
    // little-endian, младшие разряды по меньшему адресу
    b0 = 0xb2;
    b1 = 0xa1;    
    b_write(a, b0);
    b_write(a+1, b1);
    wres = w_read(a);
    // тут полезно написать отладочную печать a, w, wres
    fprintf(stderr, "a=%06o b1=%02hhx b0=%02hhx wres=%04x\n", a, b1, b0, wres);
    assert(w == wres);
    
    // еще тесты
}
int main()
{
    test_mem();
    return 0;
}
``` 

Задание: пишем тесты, придумываем недостающие. 

Пока их нельзя запустить, потому что нет реализации функций чтения и записи.

