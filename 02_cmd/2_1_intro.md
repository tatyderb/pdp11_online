# Постановка задачи урока - определение текущей команды

lesson = 318778

## SKIP VIDEO Общее видео урока

Общее видео урока


## SKIP VIDEO Повторяем что уже сделали

Видео фрагмента


## Что сделано

PDP-11 - 16 битная, little-endian, 64 килобайт памяти.

* Определены типы `byte`, `word`.
* Объявлен массив `mem`, эмулирующий память RAM.
* Написаны функции для работы с памятью:
    * `b_read`
    * `b_write`
    * `w_read`
    * `w_write`
* Написаны юнит-тесты для этих функций.
* Написана функция загрузки в память исполняемого файла.
* Код в git репозитории.

## Цель урока

Цель курса - научиться корректно выполнять загруженную программу.

В этом модуле мы будем проходить по коду программы и печатать названия знакомых команд. Из множества команд в нашем первом тесте будут только команды `mov`, `add`, `halt`. 

Не выполнять, а только определять, что у нас "знакомая команда". Как ребенок, который учится читать и ищет в тексте знакомые буквы, мы будем в коде программы искать знакомые команды.

Код нашего эмулятора будет оформлен в виде проекта - не одним большим файлом, а в нескольких связанных между собой файлах.

## Регистры - быстрая память

64 килобайт RAM по тем временам было много, но память была медленная. То есть каждая операция чтения и записи занимала много времени. Более быстрая память была очень дорогая. Чтобы найти компромисс между размером памяти, ее быстродействием и ценой компьютера, сделали дополнительную быструю память маленького размера. Ячейки этой быстрой памяти назвали **регистры**.

* Регистров 8 штук. К ним обращаются по именам R0, R1, ... R7.
* Все регистры размером 16 бит.
* Ко всем регистрам обращаются одинаковым образом.
* Нельзя обратиться к половине регистра (старшему или младшему байту).

В эмуляторе регистры стоит объявить как массив слов.

```cpp
word reg[8];    // reg[i] - это регистр Ri
```

**Задание**: объявите массив для эмуляции регистров в своем коде.

## Первая программа

Интеграционные тесты - это программы на ассемблере PDP-11, которые мы будем выполнять.

Репозиторий [https://github.com/tatyderb/pdp11_tests](https://github.com/tatyderb/pdp11_tests)

Первый тест `01_sum` складывает 2+3, результат 5 будет лежать в регистре R1. 

Файл `01_sum.pdp`:
```cpp
. = 1000    ; код размещается с адреса 1000
mov #2, R0  ; R0 = 2 - записать число 2 в регистр R0
mov #3, R1  ; R1 = 3 - записать число 3 в регистр R1
add R0, R1  ; R1 = R0 + R1 - сумму регистров R0 и R1 записать в R1
halt        ; остановить выполнение программы
```

* Все числа **восьмеричные**.
* `;` - символ начала комментария.
* `.=` - не команда, а **псевдокоманда** ассемблера, потому что она не преобразуется в код, а только управляет размещением кода в памяти. Определяет где будет размещен следующий код.

По умолчанию эталонный **эмулятор начинает выполнение с адреса 1000 (восьмеричное)**. Мы тоже будем начинать выполнение программы с этого адреса.

Заметим, что результат работы команд `mov` и `add` записывается во второй аргумент. В других ассемблерах результат может писаться в первый аргумент, как в ассемблере для х86 процессора.

У нас есть "компилятор", который преобразует код в мнемониках в S-record формат в файл `01_sum.pdp.o`:

```cpp
0200 000c
c0
15
02
00
c1
15
03
00
01
60
00
00
```

Есть так же эталонный эмулятор, который умеет выполнять такие программы и печатать как идет выполнение. Это *трассировка программы*. В своем эмуляторе мы тоже будем печать трассировку программы в формате, очень похожим на формат эталонного эмулятора. Сравнивать нашу трассировку с эталонной и добиваться корректного выполнения программы. В тестах трассировка эталонного эмулятора сохранена. В первом тесте это файл `01_sum.pdp.trace`.

Программа в мнемониках называется программой на языке ассемблера PDP-11. Наши интеграционные тесты написаны на ассемблере и состоят из:

* программы на языке ассемблера PDP-11 (`01_sum.pdp`),
* листинга этой программы, в которой показаны по каким адресам хранятся какие числа и какие команды это в мнемониках, листинг пригодится при отладке (`01_sum.pdp.l`).
* исполняемого файла в S-record формате, мы его будем загружать в наш эмулятор и выполнять. (`01_sum.pdp.o`)
* файла с трассировкой (`01_sum.pdp.trace`)

Файл листинга `01_sum.pdp.l`
```cpp
000000:			. = 1000
001000:			mov 	#2, R0
	 012700
	 000002
001004:			mov 	#3, R1
	 012701
	 000003
001010:			add		R0, R1
	 060001
001012:			halt
	 000000
001014:		
```
Похож на исходный файл, добавлены две колонки - по какому адресу хранится команда и в какое число она преобразована.

Трассировка, записанная в файл `01_sum.pdp.trace`:
```
---------------- running --------------
001000: mov     #000002,r0              [001002]=000002 
001004: mov     #000003,r1              [001006]=000003 
001010: add     r0,r1                   R0=000002 R1=000005 
001012: halt                            

---------------- halted ---------------
r0=000002 r2=000000 r4=000000 sp=000000
r1=000005 r3=000000 r5=000000 pc=001014
psw=000000: cm=k pm=k pri=0        [4]
```

**Задание**: скачайте все тесты себе на компьютер. Положите исполняемый файл первого теста так, чтобы его было удобно загружать при запуске вашего эмулятора.

## Структура проекта

Как удобно организовать файлы проекта. Пусть проект лежит в директории `pdp11`

```cpp
pdp11 - корень проекта
   src - директория с исходниками, `.c` и `.h` файлами
      pdp11.c - наш главный файл с main
      mem.c - сюда положим функции работы с памятью
      command.c - сюда положим реализации команд ассемблера
      ... - еще файлы, если понадобятся
      pdp.h - заголовочный файл
      ... - еще заголовочные файлы, если понадобятся
   tests - директория с тестами, её стоит добавить в .gitignore
   .gitignore - список того, что не коммитим в репозиторий
   Makefile - не обязателен, им удобно собирать проект и запускать тесты
```

Вы можете организовать файлы как удобно вам. 

Про разбиение на проекты и сборку Makefile расскажем позже.