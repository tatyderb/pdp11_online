# Пишем код определения текущей команды

lesson = 318784

## SKIP VIDEO Видео

https://youtu.be/nUv4ow0wmfk

## Задача урока

Вспомним, что мы должны сделать в этом модуле:

В цикле от адреса 1000 (восьмеричное) до команды `HALT`:

* читать слово
* печатать адрес и слово по формату `%06o`
* если это команда `add`, `mov` или `halt`,
    *печатать мнемонику (имя) команды
* для прочих данных печатать `unknown`
* после обнаружения команды `halt`
    * напечатать `THE END`
    * закончить выполнение программы

Так как эталонный эмулятор начинает выполнение с адреса 1000, так и наш эмулятор тоже будет начинать выполнять код с адреса 1000.

## Разобьём код на несколько файлов

Можно эту работу сделать не сейчас, а в конце этого урока, после того, как у вас первый тест стал печатать `mov`, `add`, `halt`, `unknown`. 

У нас уже написано много кода, в котором стало тяжело перемещаться. Обычно проект организуют в нескольких файлах. Идея - собрать в один файл функции и переменные, которые сильно связаны между собой и оставить используемыми извне небольшое количество функций (интерфейс).

Разбить код эмулятора на отдельные файлы можно так (пример для языка Си, возможно, ваш язык диктует немного другое разбиение):

* `main.c` - `main()` и разбор аргументов командной строки, загрузка программы, возможно вызов функции запуска юниттестов;
* `mem.c` - работа с памятью, функции `w_read`, `w_write`, `b_read`, `b_write`, при этом массив `mem[]` можно определить как `static`, потому что к нему мы обращаемся в других файлах только через эти функции; там же определим массив `word reg[8];` как глобальный, потому что будем к нему обращаться в других файлах программы;
* `command.c` - реализация всех команд ассемблера (add, mov, halt и так далее), потому что их много;
* `run.c` - функция цикла выполнения программы (напишем сегодня) и разбора аргументов (это на следующем уроке);
* `test_mem.c` - юниттесты для функций работы с памятью, `test_*.c` - юниттесты для дальнейших блоков, например команд.

Можете разбить на файлы по-своему. 

**За код в едином файле оценка за зачет будет снижена на 1 балл.**

### Что писать в .h файлах и как их организовывать?

1. Не забудьте в каждый .h файл написать `#pragma once`, чтобы каждый файл был вставлен в нужный .c файл не более одного раза.
2. Интерфейс к файлу (то есть как будут использовать в других файлах функции и переменные из этого файла) нужно написать в отдельном .h файле и вставлять его в другие .c файлы, где используются функции данного .c файла. Разберем эту мысль на примере организации кода для функций работы с памятью.

* `mem.c` - содержит 
    * реализацию функций `w_read`, `w_write`, `b_read`, `b_write`,
    * объявление массива `static byte mem[MEMSIZE];`, словом `static` мы подчеркиваем, что нигде в других файлах к массиву `mem` не будут доступаться напрямую, только через функции (массив может быть word, как вы сделали),
    * объявление массива `word reg[REGSIZE];`, к нему будут доступаться напрямую.
* `mem.h` - все, что нужно для работы извне:
    * typedef для byte и word (поэтому этот .h файл должен включаться до других наших файлов),
    * `extern word reg[REGSIZE];` и ничего про массив `mem`, потому что снаружи к нему запретили доступ,
    * `#define pc reg[7]` - потому что это тоже относится к работе с памятью,
    * `#define REGSIZE 8` - до `extern word reg`, потому что REGSIZE должно быть определено раньше, чем использовано,
    * прототипы функций `w_read`, `w_write`, `b_read`, `b_write`
* где написать?
    * `#define MEMSIZE (64*1024)` - это не относится к работе с файлом извне. Поэтому можно выбрать один из вариантов:
        * написать его в `mem.c`, 
        * сделать отдельный .h файл для "внутреннего пользования", который будет вставлен только в `mem.c` - идеологически самый верный вариант,
        * дописать в `mem.h`, потому что лень создавать отдельный .h файл ради одной строчки кода.   

## Главный цикл выполнения программы
    
Мы уже определили 8 регистров по 16 бит и сделали так, что в коде можно обращаться к последнему регистру или `reg[7]`, или `pc`:

```cpp
word reg[8];        // массив регистров R0..R7
#define pc reg[7]   // к rep[7] можем обращаться как pc
```
Выполнение уже загруженной программы реализуем в функции `run`. Так как пока не понятно как будет написано определение команды `halt`, то напишем бесконечный цикл. Выход из него по `halt` опишем позже. Сейчас нужно читать слово, печатать адрес и слово по этому адресу. Никаких прямых обращений к массиву `mem`, доступ только через написанные функции:
```cpp
void run()
{
    // следующее слово будем читать по адресу 1000 (восьмеричное)
    pc = 01000;
    
    word w;     // текущее слово, которое содержит команду
    // главный цикл выполнения программы
    while(1) {
        // читаем текущее слово
        w = w_read(pc);
        // печатаем адрес и слово по этому адресу, как в листинге
        trace(TRACE, "%06o %06o: ", pc, w);
        // pc сразу же указывает на следующее неразобранное слово
        pc += 2;
        // тут будем искать какая команда закодирована в слове w
        // ...
        
    }
}
```
Если у вас не написана функция `trace` здесь и далее используйте `printf`.

Почему формат печати чисел `%06o`? Числа все восьмеричные. В листинге и трассировке эталонного эмулятора. Поэтому мы тоже печатаем числа восьмеричные по формату `%o`. В слове 16 бит, одна восьмеричная цифра - это 3 бинарных цифры, то есть 3 бита. Для записи 16 бит нужно 5 восьмеричных цифр и еще одна цифра будет всегда или 0, или 1. Итого 6 восьмеричных цифр. Команда в бинарном и восьмеричном виде:
```
|15            8|7             0| - номера бит
|0|0|0|0|1|0|1|0|1|0|0|0|0|0|0|0| - содержимое бит, бинарные числа
|0|  0  |  5  |  2  |  0  |  0  | - содержимое бит, восьмеричные числа
```
16 бинарных цифр, 6 восьмеричных цифр. Чтобы все числа были одинаковой ширины и печать была аккуратная, будем печатать лидирующие нули по формату `%06o`.

## Разбор команды halt

Код команды `halt` 0, то есть проверка на "слово в переменной `w` - это команда `halt`?" простая:

```cpp
if (w == 0) {
    trace(TRACE, "halt ");
    do_halt();
}    
```
Сразу же напечатаем трассировку (имя команды) и вызовем функцию для выполнения команды `do_halt`, она без аргументов.

В файле с функциями команд реализуем функцию `do_halt`. Она должна напечатать "THE END!!!" и остановить выполнение всей программы.

```cpp
void do_halt()
{
    trace(INFO, "THE END!!!\n");
    exit(0);
}
```

THE END нужно, чтобы мы видели, что это нормальное завершение программы, а не остановка с ошибкой. Поэтому возвращаем из программы 0. Функция `exit(exit_code)` останавливает выполнение программы и возвращает из программы `exit_code`, как если бы в `main` написали `return exit_code;`

Для работы стандартной функции языка Си `exit` нужно подключить файл `stdlib.h`.

### Задание

1. Запустите код программы с одной проверкой на `halt`. Должно печататься THE END и программа должна останавливаться.


## Разбор команд add и mov

Сразу же напишем заготовки для функций `do_add` и `do_mov`. Пока аргументы команд неизвестны, эти функции ничего не делают и ничего не возвращают. Функцию  `do_nothing` напишем на всякий случай аналогичным образом.

```cpp
void do_add() {}
void do_mov() {}
void do_nothing() {}
```
Допишем в главный цикл выполнения программы код для определения команды. 

Для проверки "это команда `add`?" нужно занулить биты аргументов и сравнить оставшуюся часть с кодом операции `add`.

Код операции `add` в бинарном и восьмеричном виде:
```
|15            8|7             0| - номера бит
|0|1|1|0|s|s|s|s|s|s|d|d|d|d|d|d| - содержимое бит, бинарные числа
|0|  6  |  S  |  S  |  D  |  D  | - содержимое бит, восьмеричные числа
```
В переменной `w` записано слово. Проверка в **бинарном** виде:
```
|15            8|7             0| - номера бит
|?|?|?|?|?|?|?|?|?|?|?|?|?|?|?|?| - переменная w
|1|1|1|1|0|0|0|0|0|0|0|0|0|0|0|0| - переменная mask
|?|?|?|?|0|0|0|0|0|0|0|0|0|0|0|0| - w & mask
|0|1|1|0|0|0|0|0|0|0|0|0|0|0|0|0| - opcode команды add
```
В **бинарном** виде псевдокод проверки:
```cpp
// add 06SSDD
else if ((w & 11110000000000000) == 01100000000000000) {
    trace(TRACE, "add ");
    do_add();
}   
```

## SKIP SPACE Маска и код операции ADD

Для псевдокода 

```cpp
if ((w & mask) == opcode)
```
напишите значение переменных `mask` и `opcode` для определения является ли значение переменной `w` командой `add`.

В ответе напишите 6-значные восьмеричные числа.

| Мнемоника | Opcode | NZVC | Описание | Комментарии |
|-----|----|----|----|----|
| ADD s, d | **06**SSDD | `****` | Add | d = s + d |


mask = _____
opcode = _____

## SKIP SPACE Маска и код операции MOV

Для псевдокода 

```cpp
if ((w & mask) == opcode)
```
напишите значение переменных `mask` и `opcode` для определения является ли значение переменной `w` командой `mov`.

В ответе напишите 6-значные восьмеричные числа.

| Мнемоника | Opcode | NZVC | Описание | Комментарии |
|-----|----|----|----|----|
| MOV s,d    | 01SSDD   | `**0-`   | Move                         | d=s          | 

mask = _____
opcode = _____

## SKIP SPACE Маска и код операции HALT

Для псевдокода 

```cpp
if ((w & mask) == opcode)
```
напишите значение переменных `mask` и `opcode` для определения является ли значение переменной `w` командой `halt`.

В ответе напишите 6-значные восьмеричные числа.

| Мнемоника | Opcode | NZVC | Описание | Комментарии |
|-----|----|----|----|----|
| HALT | *000000* | `----` | Halt | |

mask = _____
opcode = _____

## SKIP SPACE Маска и код операции INC

Для псевдокода 

```cpp
if ((w & mask) == opcode)
```
напишите значение переменных `mask` и `opcode` для определения является ли значение переменной `w` командой `inc`.

В ответе напишите 6-значные восьмеричные числа.

| Мнемоника | Opcode | NZVC | Описание | Комментарии |
|-----|----|----|----|----|
| INC d      | 0052DD   | `***-`   | Increment                    | d=d+1        | 

mask = _____
opcode = _____

## SKIP SPACE Маска и код операции SOB

Для псевдокода 

```cpp
if ((w & mask) == opcode)
```
напишите значение переменных `mask` и `opcode` для определения является ли значение переменной `w` командой `sob` (не нужно понимать, что делает команда, нужно определить это команда `sob` или нет).

* **R** - аргумент длиной 3 бита,
* **NN** - аргумент длиной 6 бит.

В ответе напишите 6-значные восьмеричные числа.

| Мнемоника | Opcode | NZVC | Описание | Комментарии |
|-----|----|----|----|----|
| SOB  r,a    | 077RNN   | `----`   | Subtract One and Branch      | PC=PC-2*NN  #| 

mask = _____
opcode = _____

## Задание

1. Перепишите код проверки `add` в **восьмеричном** виде. Запустите программу с первым тестом, должно один раз напечататься `add` и `halt`.
2. Допишите код проверки для команды `mov`. Запустите программу с первым тестом, должны печататься `mov`, `add`, `halt`.
3. Если слово не подходит ни одной команде, печатайте `unknown`.
4. Перепишите проверку для команды `halt` в том же стиле, как и для `add` и `mov`, через маску и код операции.
5. Посмотрите на список всех команд ассемблера. Подумайте, сколько места будет занимать код, если мы его напишем в стиле if..else if... else if ... else. Подумайте, можно ли написать код компактнее. Хорошо подумайте. Потом идите на следующий шаг.

Тест **01_sum** должен при выполнении напечатать и остановиться.

```
001000 012700 : mov
001002 000002 : unknown
001004 012701 : mov
001006 000003 : unknown
001010 060001 : add
001012 000000 : halt
THE END!
```

## Свертка в цикл поиска кода операции

Каждую команду мы разбираем и выполняем так:

```cpp
if ((w & mask) == opcode) {
    trace(TRACE, "%s ", name);
    do_command();
}
```
где 

* `mask` - маска команды,
* `opcode` - код операции команды с нулями в части аргументов,
* `name` - мнемоника команды,
* `do_command` - функция без аргументов, которая исполняет команду.

Свернем эту информацию об **одной** команде в структуру

```cpp
typedef struct {
    word mask;
    word opcode;
    char * name;
    void (*do_command)(void);
} Command;
```
Объявим массив структур, которые описывают все наши команды. Допишите данные для команд `halt`, `add`, `mov`.
```cpp
Command command[] = {
    {0170000, 0060000, "add", do_add},
    // и так далее для mov и halt
}
```
Этот массив можно определить в том же файле, где реализованы функции `do_add`, `do_mov`, `do_halt`, ниже всех функций, *чтобы не писать много прототипов*. Если вы не ленивый студент, то пишите по-человечески, в начале файла. Потому что глобальные переменные принято писать в начале файла, а не в самом его конце.

 
### Задание

1. Запишите данные о командах  `halt`, `add`, `mov` в виде массива структур `Command`.
2. Перепишите код разбора команд через цикл с использованием этого массива.

