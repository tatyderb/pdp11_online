# Постановка задачи урока - определение текущей команды

lesson = 318780

## SKIP VIDEO Инсталляция эталонного эмулятора

Внимание! Этот **раздел можно пропустить**, так как компилятор и эталонный эмулятор нужен только для создания новых интеграционных тестов. Если вы пользуетесь уже написанными интеграционными тестами, можно не устанавливать данные программы.

https://youtu.be/noXb0ySE4I4

## Скачайте архив

* [Linux](https://stepik.org/media/attachments/lesson/347539/pdp11em-linux.zip) - если у вас Windows + WSL, то берите этот архив и выполняйте инструкцию для Linux.
* [Windows](https://stepik.org/media/attachments/lesson/347539/pdp11em-win32.rar) - 32-битная версия, возможны проблемы при работе, у кого получилось запустить, напишите в комментариях, где работает и что нужно было еще сделать кроме инструкции.
* [Mac](https://stepik.org/media/attachments/lesson/347539/pdp11em-win32.rar)

## Linux, MAC(он же Windows + WSL)

1. Разверните файл архива в ту директорию, где будете работать с эталонным эмулятором.
2. Запустите терминал Linux (или WSL).
3. Перейдите в директорию с развернутым архивом с помощью команды `cd путь_к_директории`
4. Добавьте права на исполнение файлам `as11` и `pdp11` командами:
```
chmod +x as11
chmod +x pdp11
```
5. Проверьте, что работает, запустите `./as11` (компилятор), должно вывести справку по работе с программой. Аналогично для `./pdp11` (эталонный эмулятор).
6. **Если не работает**, добавьте права на исполнение файлам `.static`
```
chmod +x as11.static
chmod +x pdp11.static
```
7. Проверьте, что `as11.static` (компилятор) и `pdp11.static` (эталонный эмулятор) работают.

Если в директории нельзя будет создавать новые файлы, добавьте права на запись в текущую директорию (мы же не можем изменять информацию о состоянии текущей директории) командой
```cpp
chmod +w .
```

## Windows

1. Распакуйте архив в директорию.
2. Откройте проводник (Explorer) и перейдите в нем в директорию с файлами (скопируйте путь к этой директории)
3. Запустите терминал Windows: нажмите Win+R и введите `cmd.exe`, нажмите клавишу Enter.
4. В запущенном терминале перейдите в нужную директорию. Путь к директории вы могли скопировать в пункте 2. Переходим командой `cd`:
```cpp
cd /D "путь к директории с файлами в кавычках"
```
* `/D` нужно, если переходить придется на другой диск,
* кавычки нужны, если в пути есть пробел.
* можно набрать путь вручную, а не копировать и вставлять.
    
Запуск терминала Windows:

![cmd.exe](https://stepik.org/media/attachments/lesson/318780/cmd.png)

Переход в директорию с файлами компилятора и эталонного эмулятора:

![cd](https://stepik.org/media/attachments/lesson/318780/win_install_small.png)

## as11 - компиляция программы на ассемблере PDP-11

На этом шаге и дальше сами смотрите, как именно нужно запускать ваши программы: as11, as11.exe или as11.static. И pdp11-что-то-там.

Пусть у нас исходная программа на ассемблере лежит в файле `sum.txt`. Компилятору все равно, какое расширение у файла, хоть `.png`, хоть без расширения. В Windows могут быть проблемы с текстовым редактором, поэтому рекомендуем все файлы делать с расширением `.txt`, а изменять имена файлов.

Показывать как работать будем на примере Linux, но кроме названия файла компилятора и эталонного эмулятора, нет никакой разницы в использовании этих программ.

Запустим программу без аргументов. Она напечатает справку по работе с этой программой.
```
./as11.static
Usage: ./as11.static [-l listing-file] [-o output-file] assembly-file
```
То есть у нас есть обязательный аргумент - файл с программой на ассемблере и два необязательных.

`-l файл` (от listing) - создать [листинг-файл](https://stepik.org/lesson/318778/step/6) с именем *файл*.

`-o файл` (от output) - создать файл в формате S-record (исполняемый для эмулятора PDP-11) с именем *файл*.

Например:
```
./as11.static -l sum_l.txt -o sum_o.txt sum.txt
```

* `sum.txt` - исходный файл,
* `sum_l.txt` - листинг,
* `sum_o.txt` - исполняемый файл, на следующем шаге мы его будем исполнять.

## Запуск программы на эталонном эмуляторе

У нас есть исполняемый файл в S-record формате `sum_o.txt` и эталонный эмулятор `pdp11.static`

Без аргументов эталонный эмулятор пишет, какие именно аргументы он понимает:
```
./pdp11.static

Usage: ./pdp11.static [options] initial-core-file [options to emulated program]

Options:
        -s N    starting address, octal (default 1000)
        -n      do not pass argc/argv to target
        -q      quiet, don't show anything except target's output
        -t      show trace to stderr
        -T      show verbose trace to stderr
        -o      run with ODT debugger enabled

ODT commands:
        0-7     octal digits, address specification
        g       go, run from specified address
        s       step, single step from specified address or current PC
        p       continue, run from current PC
        rX      register specification, X is 0-7 for R0-R7 or s for PSW
        /       open register or memory location for view/modify
        <, >, space     open prev/next register or memory location
        i       open instruction (disassembled)
        ^p      break, enter ODT
        Q       quit simulator
```
Во-первых, у эмулятора есть отладчик ODT для пошагового выполнения программ, выполнения до указанной точки остановки, инспектирования регистров и флагов.

Нас больше интересуют опции `-t` (трассировка) и `-T` (подробная трассировка).

Запуск исполняемого файла с трассировкой:
```
./pdp11.static -t sum_o.txt
```

Запуск исполняемого файла без трассировки:
```
./pdp11.static sum_o.txt
```
Для первого теста получим:
```
---------------- running --------------
001000: mov     #000002,r0              [001002]=000002 
001004: mov     #000003,r1              [001006]=000003 
001010: add     r0,r1                   R0=000002 R1=000005 
001012: halt                            

---------------- halted ---------------
r0=000002 r2=000000 r4=000000 sp=000000
r1=000005 r3=000000 r5=000000 pc=001014
psw=000000: cm=k pm=k pri=0        [4]
```
На следующих шагах мы начнем печатать похожее на эту трассировку. **Последний столбец трассировки не нужно реализовывать**. В нем пишется по каким адресам и как изменяются данные текущей командой.

## Что научились делать?

### Писать на ассемблере программу сложения двух чисел

Файл sum.txt:
```
.= 1000     ; разместим код начиная с адреса 1000
mov #2, R0  ; R0 = 2
mov #3, R1  ; R1 = 3
add R0, R1  ; R1 = R0 + R1
halt        ; завершение программы
```
Команды и имена регистров можно писать как маленькими, так и большими буквами. Компилятор понимает.

### Компилировать его в терминале командой

```
./as11 -l sum.l -o sum.o sum.txt
```

### Файл листинга sum.l

В полученном файле листинга `sum.l` смотреть машинный код (по каким адресам какие числа лежат) и к какой команде он относится:

```
000000:			. = 1000
001000:			mov 	#2, R0
	 012700
	 000002
001004:			mov 	#3, R1
	 012701
	 000003
001010:			add		R0, R1
	 060001
001012:			halt
	 000000
001014:			
```
* все числа восьмеричные;
* первая колонка - адреса 001000, 001004, 001010, 001012, 001014;
* вторая колонка - машинный код, в который преобразуются команды, как именно, мы узнаем на этом уроке, 012700 и так далее
* далее - ассемблерный код, и которого получился указанный машинный код.

### Исполняемый файл в формате S-record sum.o

Все числа **шестнадцатеричные**.

```
0200 000c
c0
15
02
00
c1
15
03
00
01
60
00
00
```

### Исполнить этот файл на эталонном эмуляторе

```
./pdp11.static -t sum_o.txt
```

И получить трассировку выполнения программы. В репозитории с тестами есть трассировка для каждого теста. Сверяйтесь с ней.

```cpp
---------------- running --------------
001000: mov     #000002,r0              [001002]=000002 
001004: mov     #000003,r1              [001006]=000003 
001010: add     r0,r1                   R0=000002 R1=000005 
001012: halt                            

---------------- halted ---------------
r0=000002 r2=000000 r4=000000 sp=000000
r1=000005 r3=000000 r5=000000 pc=001014
psw=000000: cm=k pm=k pri=0        [4]
```
Видно, что в регистре **r0** число 2, в регистре **r1** число 5.