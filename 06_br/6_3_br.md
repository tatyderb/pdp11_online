# Кодирование команд ветвления. BR

lesson = 320178

## SKIP VIDEO Все видео

https://youtu.be/J9IlLahWxP4

## Переход по адресу

Что такое "перейти в программе по адресу Х"? Это значит, следующая команда будет читаться из адреса Х. То есть `PC = X` и переход сделан.

### MOV

В ассемблере это можно написать так:
```cpp
    mov #X, R7
    ...
X:  ...
```

### JMP

Именно так работает команда **JMP** (jump, прыжок) - переход по указанному адресу
```cpp
    jmp X
    ...
X:  ...
```
Плюс: может перейти по любому адресу, никаких ограничений.
Минус: занимает 2 слова, а нам хочется и условие, и переход уместить в одном слове.

### SOB

Мы уже знаем еще одну команду, которая проверяет условие, переходит по адресу и умещается в одном слове, **SOB**:
```cpp
LOOP:  
    ...
    sob R1, LOOP
```
Минусы: переход только назад, в сторону уменьшения адреса, не более 077 слов назад. Потому что аргумент NN, на сколько слов назад мы переходим, содержит 6 бит.

### BR

**Безусловный** переход, кодируемый в одно слово **BR** рассмотрим подробнее на следующем шаге.

## BR : 0004XX

**Безусловный** переход, кодируемый в одно слово **BR**.

* ХХ - 8 бит (кодирует на сколько слов изменим текущий адрес).
* ХХ - **знаковое**, то есть можно прыгать как вперед, так и назад.
* PC = PC + XX * 2

### Пример прыжка вперед

```cpp
1000: 000402    br A
1002: 012700    mov #2, R0
1004: 000002
1006: 012701 A: mov #3, R1
1010: 000003  
```
Когда разбирается команда `br A`, PC=1002.

Надо перейти на 2 слова и попасть на адрес 1006. То есть в ХХ кодируем сдвиг 2.

```
|15            8|7             0| - номера бит
|0|0|0|0|0|0|0|1|x|x|x|x|x|x|x|x| - код операции
|0|0|0|0|0|0|0|1|0|0|0|0|0|0|1|0| - содержимое бит, бинарное число
|0|  0  |  0  |  4x |  X  |  X  | - содержимое бит, восьмеричные числа
|0|  0  |  0  |  4  |  0  |  2  | - содержимое бит, восьмеричные числа
```
Заметим, что цифра 4 складывается как из 1 от кода операции, так и из двух бит аргумента. В этом примере это 00 и получаем 100 (бинарное), то есть 4 (восьмеричное).

Команда `br A` кодируется как 000402.

### Пример прыжка назад

```cpp
1000: 012700    mov #2, R0
1002: 000002
1004: 000775    br A
1006: ...
```
Когда разбирается команда `br A`, PC=1006.

Надо перейти на 3 слова **назад** и попасть на адрес 1000. То есть в ХХ кодируем сдвиг -3.

Разберем, как из кода операции 0004XX и сдвига XX=-3 получается 000735.

-3 надо закодировать в 8 битах аргумента ХХ, это 11111101 (бинарное). Разобъем его на тройки, `11 111 101`. То есть первые `11` войдут в восьмеричное число, которое формируется из кода операции `1` и аргумента `11`. Получим `111`, то есть 7.

`br A` кодируется как 000775 (при коде операции 000400). Обратите внимание, цифра 4 превратилась в цифру 7.

```
|15            8|7             0| - номера бит
|0|0|0|0|0|0|0|1|x|x|x|x|x|x|x|x| - код операции
|0|0|0|0|0|0|0|1|1|1|1|1|1|1|0|1| - содержимое бит, бинарное число
|0|  0  |  0  |  4x |  X  |  X  | - код операции, восьмеричные числа
|0|  0  |  0  |  7  |  7  |  5  | - содержимое бит, восьмеричные числа
```
Как быстро в уме переводить отрицательный сдвиг в восьмеричные цифры? Заметим, что при сложении 8-битного положительного и соответствующего ему отрицательного числа, будет переполнение. Запишем получившийся 0 "честно", как 9-битное число:
```
8|7             0| - номера бит
 |x|x|x|x|x|x|x|x| - аргумент ХХ
 |0|0|0|0|0|0|1|1| - 3
 |1|1|1|1|1|1|0|1| - -3
------------------
1|0|0|0|0|0|0|0|0| - 3+(-3)
  4  |  0  |  0  |
```
То есть с переполнением будет 400. Вопрос: к какому **восьмеричному** числу надо прибавить 3, чтобы получилось 400? Это число 375. То есть -3 кодируется в *восьмеричном* 8-битовом виде как 375.

Добавим аргумент 375 к коду операции 000400, получим
```
000400
   375
------
000775
```

## Условные ветвления

Все команды условных ветвлений проверяют какое-то условие и переходят по адресу. То есть функция реализации команды должна проверять условие и вызывать функцию `do_br`. Например, команда **BPL** (branch if plus) проверяет, если флаг N равен 0, то переходит по адресу.

```cpp
void do_bpl()
{
    if (N == 0)
        do_br();
}
```
Используйте код повторно! Вызывайте функцию `do_br`.

| Мнемоника    | Opcode   | NZVC   | Описание                  | Комментарии        | 
|----|----|----|----|----|
| BCC  a      | 1030XX   | `----`   | Branch if Carry Clear        | If C=0       | 
| BCS  a      | 1034XX   | `----`   | Branch if Carry Set          | If C=1       | 
| BEQ  a      | 0014XX   | `----`   | Branch if Equal              | If Z=1       | 
| BGE  a      | 0020XX   | `----`   | Branch if Greater or Equal   | If NxV=0     | 
| BGT  a      | 0030XX   | `----`   | Branch if Greater Than       | If Zv{NxV}=0 | 
| BHI  a      | 1010XX   | `----`   | Branch if Higher             | If CvZ=0     | 
| BHIS a      | 1030XX   | `----`   | Branch if Higher or Same     | If C=0       | 
| BLE  a      | 0034XX   | `----`   | Branch if Less or Equal      | If Zv{NxV}=1 | 
| BLT  a      | 0024XX   | `----`   | Branch if Less Than          | If NxV=1     | 
| BLO  a      | 1034XX   | `----`   | Branch if Lower              | If C=1       | 
| BLOS a      | 1014XX   | `----`   | Branch if Lower or Same      | If CvZ=1     | 
| BMI  a      | 1004XX   | `----`   | Branch if Minus              | If N=1       | 
| BNE  a      | 0010XX   | `----`   | Branch if Not Equal          | If Z=0       | 
| BPL  a      | 1000XX   | `----`   | Branch if Plus               | If N=0       | 
| BR   a      | 0004XX   | `----`   | Branch                       | PC=PC+2*XX   | 
| BVC  a      | 1020XX   | `----`   | Branch if Overflow Clear     | If V=0       | 
| BVS  a      | 1024XX   | `----`   | Branch if Overflow Set       | If V=1       | 

**В эмуляторе можно реализовать только те команды, которые встречаются в интеграционных тестах.** Команд много, времени до зачета мало.