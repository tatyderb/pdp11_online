# Моды 0, 1, 2

lesson = 894644

## Rn, мода 0, регистровый режим адресации

`Rn` - **значение находится в указанном регистре** с номером `n`.

Пример использования:
```cpp
INC R3      ; увеличить значение регистра R3 на 1
ADD R0, R1  ; в регистр R1 записать сумму чисел, лежащих в R0 и R1
``` 
Введем условные обозначения. **Rn** - регистр с номером `n`.

Для понимания работы мод адресации будем записывать их действие в псевдокоде, где `reg` - это "массив" регистров, а `mem` - это "массив" RAM. *Псевдокод я ввожу для короткой записи, разъясняющей, как работает режим адресации. Это не тот массив `mem`, что у нас в эмуляторе, доступ к памяти эмулятора мы делаем только через функции `w_read`, `w_write`, `b_read`, `b_write`.*

```cpp
adr = n         // куда (адрес)
val = reg[n]    // что (значение)
```
Если в `R3` уже лежало число 5, то `INC R3` изменит значение, в регистре `R3` теперь лежит число 6.

![mode0.png](https://stepik.org/media/attachments/lesson/325592/mode0.png)

### Пример кодирования мнемоники

```cpp
add R0, R1
```
команда кодируется как
```
|15            8|7             0| - номера бит
|0|1|1|0|m|m|m|r|r|r|m|m|m|r|r|r| - содержимое бит, бинарные числа
|0|  6  |  S  |  S  |  D  |  D  | - содержимое бит, восьмеричные числа
```
Запишем моду 0 и регистры 0 и 1 для аргументов:
```
|15            8|7             0| - номера бит
|0|1|1|0|m|m|m|r|r|r|m|m|m|r|r|r| - содержимое бит, бинарные числа
|0|1|1|0|0|0|0|0|0|0|0|0|0|1|1|1| - содержимое бит, бинарные числа
|0|  6  |  0  |  0  |  0  |  1  | - содержимое бит, восьмеричные числа
```

## `(Rn)` Мода 1, косвенно-регистровый режим адресации

Две формы записи, или `INC (R3)`, или `INC @R3`.

Как имея регистр, доступиться к памяти? Адрес в памяти занимает 16 бит, размер регистра тоже 16 бит. То есть регистр может хранить число, которое можно считать адресом какой-то ячейки памяти.

Три варианта объяснения одного и того же:

* В регистре `Rn` находится число. Это число - адрес в памяти.
* Регистр содержит адрес операнда.
* В регистре лежит номер ячейки памяти, где лежит значение.

```cpp
adr = reg[n]
val = mem[adr] 
```

![mode1.png](https://stepik.org/media/attachments/lesson/325592/mode1.png)

Если в регистре `R3` лежит число 1000, то `INC (R3)` возьмет это число 1000, пойдет в **память** по адресу 1000, найдет там число 5 и заменит его на 6.

Очень похоже на оператор `*` в языке Си. `*p` - содержимое переменной `p` трактовать как адрес, пойти по этому адресу, взять/записать значение по этому адресу в памяти.

### Пример кодирования мнемоники

```cpp
inc (R3)
```
команда кодируется как
```
|15            8|7             0| - номера бит
|0|0|0|0|1|0|1|0|1|0|d|d|d|d|d|d| - содержимое бит, бинарные числа
|0|  0  |  5  |  2  |  D  |  D  | - содержимое бит, восьмеричные числа
```
Запишем моду 1 и регистр 3 в аргумент:
```
|15            8|7             0| - номера бит
|0|0|0|0|1|0|1|0|1|0|m|m|m|r|r|r| - содержимое бит, бинарные числа
|0|0|0|0|1|0|1|0|1|0|0|0|1|0|1|1| - содержимое бит, бинарные числа
|0|  0  |  5  |  2  |  1  |  3  | - содержимое бит, восьмеричные числа
```

## (Rn)+, мода 2, автоинкрементный режим адресации

С помощью этого режима удобно перебирать массив чисел.

```cpp
INC (R3)+
```
Как работает режим:

* Регистр содержит адрес операнда, 
* по этому адресу лежит значение,
* содержимое **регистра** увеличивается на 2 или на 1 (если это байтовая операция на регистрах R0..R5)

**Регистры R6 и R7 всегда увеличиваются на 2.**

Потому что если мы увеличим регистр `R7` на 1, его значение станет нечетным. По этому нечетному адресу пытаемся читать следующую команду, а у нас все слова начинаются по четным адресам. Машина сломалась.

Псевдокод:
```cpp
adr = reg[n]
val = mem[adr]
reg[n] += 2    (или 1)
```
Как видите, это почти режим 1, только **потом** значение регистра увеличивается.

Плюс отрабатывается **после** нахождения адреса и значения, поэтому его пишут в конце аргумента `(R3)+`.

![mode2.png](https://stepik.org/media/attachments/lesson/325592/mode2.png)

Если в регистре `R3` лежит число 1000, то `INC (R3)` возьмет это число 1000, пойдет в **память** по адресу 1000, найдет там число 5.
В регистре `R3` станет число 1002, в памяти число 5 заменится на 6.

Мода 0 позволяет обращаться к регистру, мода 1 позволяет обращаться к памяти. Зачем другие режимы? Они введены, чтобы программа была короче. Если в регистре R1 адрес элемента массива из чисел и мы хотим просуммировать эти числа, нужно считывать число по адресу из этого регистра и увеличивать значение так, чтобы регистр указывал на следующий элемент массива (содержал его адрес). Пусть сумма накапливается в `R5`. То есть вместо кода
```cpp
add (R1), R5   ; число по адресу, лежащему в R1, добавили в R5
add #2, R1     ; этот адрес увеличили на 2
```
можно написать короче
```cpp
add (R1)+, R5  ; прибавили число, увеличили адрес
```

Почему адрес может увеличиваться на 1, а не на 2? Команда копирования может работать с байтами `movb`, массив чисел может быть таким, что одно число занимает 1 байт. Тогда для адресации по этому массиву нужно будет добавлять +1 к адресу после обработки ячейки по этому адресу.

### Пример кодирования мнемоники

```cpp
inc (R3)+
```
команда кодируется как
```
|15            8|7             0| - номера бит
|0|0|0|0|1|0|1|0|1|0|d|d|d|d|d|d| - содержимое бит, бинарные числа
|0|  0  |  5  |  2  |  D  |  D  | - содержимое бит, восьмеричные числа
```
Запишем моду 2 и регистр 3 в аргумент:
```
|15            8|7             0| - номера бит
|0|0|0|0|1|0|1|0|1|0|m|m|m|r|r|r| - содержимое бит, бинарные числа
|0|0|0|0|1|0|1|0|1|0|0|1|0|0|1|1| - содержимое бит, бинарные числа
|0|  0  |  5  |  2  |  2  |  3  | - содержимое бит, восьмеричные числа
```

## `#nn` мода 2 по регистру R7, непосредственный режим адресации

**Работает абсолютно так же, как мода 2**, разобранная раньше. Разница только в условном обозначении, когда пишем программу в мнемониках.

```cpp
mov #3, R1
```
Этот код работает так же как
```cpp
mov (R7)+, R1   
.WORD 3         ; положить в это слово число 3
```

![mode2_pc.png](https://stepik.org/media/attachments/lesson/325592/mode2_pc.png)

* Пусть команда `mov` лежит по адресу 1004. Она закодирована как 012701.
* В следующем слове по адресу 1006 пусть лежит число 3.
* Как только мы прочитали команду из 1004 адреса, `PC` стало равно 1006. Это не разбор моды, это главный цикл обработки команд. Читаем новую команду и **сразу** увеличиваем `PC` на 2. Теперь в `R7` лежит число 1006.
* Разбираем первый аргумент, 27. Из `R7` читаем 1006, это адрес, идем по нему и получаем число 3. `R7` сразу увеличилось на 2. В `pc` адрес следующей команды, которую нужно разобрать.

Псевдокод такой же:
```cpp
adr = reg[7]
val = mem[adr]
reg[n] += 2    (или 1)
```
**Во 2 моде по 7 регистру изменяется только мнемоника**. Но никто вам не мешает писать `(R7)+` и использовать `.WORD` для размещения числа.
 
### Экономия памяти

Теперь мы можем сравнить в какой код преобразуются фрагменты кода.

```cpp
add (R1), R5   ; число по адресу, лежащему в R1, добавили в R5
add #2, R1     ; этот адрес увеличили на 2
```
кодируется в 3 слова:
```cpp
061105
062701
000002
```
Код, который делает то же самое:
```cpp
add (R1)+, R5  ; прибавили число, увеличили адрес
```
кодируется в 1 слово:
```cpp
062105
```
Экономия памяти в 3 раза. Разнообразие режимов адресации делает программу читабельнее и короче.

## NUMBER Кодируйте команду

В какой код кодируется команда
```cpp
mov R5, (R2)
```
Ответ запишите в виде 6-значного восьмеричного числа.

ANSWER: 010512

