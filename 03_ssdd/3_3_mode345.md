# Моды 3, 4, 5

lesson = 894646

## @(Rn)+, мода 3, косвенный автоинкрементный режим адресации

С помощью этого режима удобно перебирать массив адресов (то есть указателей, например, адресов строк).

Режим очень похож на 2 моду, но добавляется еще одно разыменование. То, что во 2 моде было значением, в третьей моде трактуется как адрес и уже по этому адресу берется значение.

```cpp
INC @(R3)+
```
Как работает режим:

* Регистр содержит адрес операнда, 
* по этому адресу лежит число,
* **это число - тоже адрес, по этому адресу берется значение**,
* содержимое **регистра** увеличивается **всегда на 2**.

Потому что в этом регистре лежит адрес **слова** (которое адрес), даже если это байтовая операция.

Псевдокод:
```cpp
adr = reg[n]
adr = mem[adr]
val = mem[adr]    добавилось еще одно разыменование
reg[n] += 2       всегда 2
```

Плюс отрабатывается **после** нахождения адреса и значения, поэтому его пишут в конце аргумента `@(R3)+`.

![mode3.png](https://stepik.org/media/attachments/lesson/894646/mode3.png)

Если в регистре `R3` лежит число 1000, то `INC @(R3)` возьмет это число 1000, пойдет в **память** по адресу 1000, найдет там число 202. Пойдет в памяти по адресу 202 и найдет там число 5.
В регистре `R3` станет число 1002, в памяти число 5 заменится на 6. Число 202 останется без изменений.

## @#nn  мода 3, регистр R7, абсолютный режим

Используется для "значение по указанному адресу"

```cpp
mov @#202, R1;  значение по адресу 202, записать в R1
```
Работает так же, как мода 3 по любому другому регистру. Отличается только запись в мнемонике.

Псевдокод:
```cpp
adr = reg[7]
adr = mem[adr]
val = mem[adr]    добавилось еще одно разыменование
reg[n] += 2       всегда 2
```
![mode3_pc.png](https://stepik.org/media/attachments/lesson/894646/mode3_pc.png)

Конечный адрес хранится в слове сразу за командой. То есть команда по адресу 1004

```cpp
mov @#202, R1
```
кодируется так:
```cpp
1004: 013701
1006: 000202
```

* Пусть команда `mov` лежит по адресу 1004. Она закодирована как 013701.
* В следующем слове по адресу 1006 пусть лежит число 202, а по адресу 202 пусть лежит число 5.
* Как только мы прочитали команду из 1004 адреса, `PC` стало равно 1006. Это не разбор моды, это главный цикл обработки команд. Читаем новую команду и **сразу** увеличиваем `PC` на 2. Теперь в `R7` лежит число 1006.
* Разбираем первый аргумент, 37. Из `R7` читаем 1006, это адрес, идем по нему и получаем число 202. 
* Идем по адресу 202 и получаем число 5.
* `R7` сразу увеличилось на 2. В `pc` адрес следующей команды, которую нужно разобрать.

## -(Rn), мода 4, автодекрементный режим

Моды 4 и 5 похожи на 2 и 3, но если раньше мы **увеличивали потом** значение регистра, то теперь мы **сначала уменьшим** значение регистра. Чтобы не забывали, что уменьшаем сначала, мы пишем знак `-` спереди.

Эти моды используются для перебора массива чисел и массива адресов с конца в начало.

```cpp
INC -(R3)
```
Как работает режим:

* Содержимое **регистра** уменьшается на 2 или на 1 (если это байтовая операция на регистрах R0..R5)
* Регистр содержит адрес операнда, 
* по этому адресу лежит значение.

**Регистры R6 и R7 всегда изменяются на 2.**

Потому что если мы уменьшим регистр `R7` на 1, его значение станет нечетным. По этому нечетному адресу пытаемся читать следующую команду, а у нас все слова начинаются по четным адресам. Машина сломалась.

Псевдокод:
```cpp
reg[n] -= 2    (или 1)
adr = reg[n]
val = mem[adr]
```
Как видите, это почти режим 1 или 2, только **сначала** значение регистра уменьшается.

Минус отрабатывается **до** нахождения адреса и значения, поэтому его пишут в начале аргумента `-(R3)`.

![mode4.png](https://stepik.org/media/attachments/lesson/894646/mode4.png)
