# Моды 3, 4, 5

lesson = 894646

## @(Rn)+, мода 3, косвенный автоинкрементный режим адресации

С помощью этого режима удобно перебирать массив адресов (то есть указателей, например, адресов строк).

Режим очень похож на 2 моду, но добавляется еще одно разыменование. То, что во 2 моде было значением, в третьей моде трактуется как адрес и уже по этому адресу берется значение.

```cpp
INC @(R3)+
```
Как работает режим:

* Регистр содержит адрес операнда, 
* по этому адресу лежит число,
* **это число - тоже адрес, по этому адресу берется значение**,
* содержимое **регистра** увеличивается **всегда на 2**.

Потому что в этом регистре лежит адрес **слова** (которое адрес), даже если это байтовая операция.

Псевдокод:
```cpp
adr = reg[n]
adr = mem[adr]
val = mem[adr]    добавилось еще одно разыменование
reg[n] += 2       всегда 2
```

Плюс отрабатывается **после** нахождения адреса и значения, поэтому его пишут в конце аргумента `@(R3)+`.

![mode3.png](https://stepik.org/media/attachments/lesson/894646/mode3.png)

Если в регистре `R3` лежит число 1000, то `INC @(R3)+` возьмет это число 1000, пойдет в **память** по адресу 1000, найдет там число 202. Пойдет в памяти по адресу 202 и найдет там число 5.
В регистре `R3` станет число 1002, в памяти число 5 заменится на 6. Число 202 останется без изменений.

## @#nn  мода 3, регистр R7, абсолютный режим

Используется для "значение по указанному адресу"

```cpp
mov @#202, R1;  значение по адресу 202, записать в R1
```
Работает так же, как мода 3 по любому другому регистру. Отличается только запись в мнемонике.

Псевдокод:
```cpp
adr = reg[7]
adr = mem[adr]
val = mem[adr]    добавилось еще одно разыменование
reg[n] += 2       всегда 2
```
![mode3_pc.png](https://stepik.org/media/attachments/lesson/894646/mode3_pc.png)

Конечный адрес хранится в слове сразу за командой. То есть команда по адресу 1004

```cpp
mov @#202, R1
```
кодируется так:
```cpp
1004: 013701
1006: 000202
```

* Пусть команда `mov` лежит по адресу 1004. Она закодирована как 013701.
* В следующем слове по адресу 1006 пусть лежит число 202, а по адресу 202 пусть лежит число 5.
* Как только мы прочитали команду из 1004 адреса, `PC` стало равно 1006. Это не разбор моды, это главный цикл обработки команд. Читаем новую команду и **сразу** увеличиваем `PC` на 2. Теперь в `R7` лежит число 1006.
* Разбираем первый аргумент, 37. Из `R7` читаем 1006, это адрес, идем по нему и получаем число 202. 
* Идем по адресу 202 и получаем число 5.
* `R7` сразу увеличилось на 2. В `pc` адрес следующей команды, которую нужно разобрать.

## NUMBER Кодирование 

Напишите, в какой код преобразуется команда `INC @(R1)+`.

Ответ - 6 восьмеричных цифр.

ANSWER: 005231

## -(Rn), мода 4, автодекрементный режим

Моды 4 и 5 похожи на 2 и 3, но если раньше мы **увеличивали потом** значение регистра, то теперь мы **сначала уменьшим** значение регистра. Чтобы не забывали, что уменьшаем сначала, мы пишем знак `-` спереди.

Эти моды используются для перебора массива чисел и массива адресов с конца в начало.

```cpp
INC -(R3)
```
Как работает режим:

* Содержимое **регистра** уменьшается на 2 или на 1 (если это байтовая операция на регистрах R0..R5)
* Регистр содержит адрес операнда, 
* по этому адресу лежит значение.

**Регистры R6 и R7 всегда изменяются на 2.**

Потому что если мы уменьшим регистр `R7` на 1, его значение станет нечетным. По этому нечетному адресу пытаемся читать следующую команду, а у нас все слова начинаются по четным адресам. Машина сломалась.

Псевдокод:
```cpp
reg[n] -= 2    (или 1)
adr = reg[n]
val = mem[adr]
```
Как видите, это почти режим 1 или 2, только **сначала** значение регистра уменьшается.

Минус отрабатывается **до** нахождения адреса и значения, поэтому его пишут в начале аргумента `-(R3)`.

![mode4.png](https://stepik.org/media/attachments/lesson/894646/mode4.png)

* Пусть в `R3` записано число 1002, а по адресу 1000, записано число 5. 
* `mov -(R3), R1` - первый аргумент `-(R3)`.
* Вычитаем 2 из содержимого регистра `R3`, там теперь число 1000.
* Число 1000 считаем адресом и читаем значение по этому адресу, число 5.
* Записываем 5 во второй аргумент команды, регистр `R1`.

## @-(Rn) мода 5, косвенный автодекрементный режим адресации

С помощью этого режима удобно перебирать массив адресов (то есть указателей, например, адресов строк) с конца.

Режим очень похож на 4 моду, но добавляется еще одно разыменование. То, что во 4 моде было значением, в пятой моде трактуется как адрес и уже по этому адресу берется значение.

Или же третья мода, у которой вместо "**потом увеличьте** значение регистра на 2" работает "**сначала уменьшите** значение регистра на 2".

```cpp
INC @-(R3)
```
Как работает режим:


* Содержимое **регистра** уменьшается **всегда на 2**,
* регистр содержит адрес операнда, 
* по этому адресу лежит число,
* **это число - тоже адрес, по этому адресу берется значение**.


Псевдокод:
```cpp
reg[n] -= 2       всегда 2
adr = reg[n]
adr = mem[adr]
val = mem[adr]    добавилось еще одно разыменование
```

Минус отрабатывается **до** нахождения адреса и значения, поэтому его пишут сначала аргумента, полученный результат разыменовываем `@-(R3)`.

![mode5.png](https://stepik.org/media/attachments/lesson/894646/mode5.png)

* Если в регистре `R3` лежит число 1002, то `INC @-(R3)` изменит значение регистра на -2, то есть в `R3` лежит число 1000.
* Возьмет это число 1000, пойдет в **память** по адресу 1000, найдет там число 206. 
* Пойдет в памяти по адресу 206 и найдет там число 5.

В памяти число 5 заменится на 6. Число 206 останется без изменений.

## Работа программы `mov -(pc), -(pc)`

Разберем как работает программа, состоящая из единственной команды, которую мы положим по адресу 1000:

```
. = 1000
mov -(pc), -(pc)
```
Оба аргумента - это 4 мода по 7 регистру, то есть код программы это `014747` (всего одно слово).

* Начало работы программы: `pc = 1000`, по адресу 1000 лежит число 014747.
* Прочитали слово по адресу 1000, `pc = 1002`.
* Разбираем первый аргумент `-(pc)`, находим **что** копируем:
    * `pc -= 2`, получим `pc = 1000` - это адрес, а **значение первого аргумента - число `014747`**, которое лежит по этому адресу.
* Разбираем второй аргумент `-(pc)`, находим куда копируем:
    * `pc -= 2`, получим `pc` равное `1000 - 2 = 776` - это адрес, куда будем копировать, обратите внимание, `pc = 776`
* Выполняем команду, записываем число `014747` по адресу 776.
* Далее разбираем следующую команду - читаем слово по адресу 776 и разбираем его. То есть наше слово копируется каждый раз на одно выше.

Программа бесконечно работает и копирует свой код в память. Перед вами пример **вируса**. Его размер 2 байта. 

Эта программа есть в интеграционных тестах. Убедитесь, что она много раз копирует себя. Она может останавливаться и падать, а может продолжать работу бесконечно. Любой вариант с множественным копированием - это корректное выполнение теста.