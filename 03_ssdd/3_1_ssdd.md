# Список команд PDP-11

lesson = 325592

## SKIP VIDEO Полное видео

https://youtu.be/ivq2rqsKgaA

## SKIP VIDEO Аргументы SS и DD, моды 0, 1, 2

https://youtu.be/Yx7bMBfnAFM

## Задача урока

* Понять, какие бывают аргументы.
* Разобраться с аргументами SS и DD.
* Добиться полной работы первого теста `01_sum`

## Аргументы команды

Вспомним нашу программу.

```cpp
. = 1000        ; начинаем с адреса 1000
mov 	#2, R0  ; R0 = 2
mov 	#3, R1  ; R1 = 3
add		R0, R1  ; R1 = R0 + R1
halt            ; конец программы
```
У команды `halt` аргументов нет.

В команде `mov` аргументы определяют **что** (число 2) **куда** (в регистр R0) записывать. То есть от первого аргумента нужно значение, а от второго - адрес, по которому записываем результат.

В команде `add` от первого аргумента нужен результат. Мы смотрим **что** нужно прибавить ко второму аргументу. Но от второго аргумента нужно и значение (**что** мы складываем, число 3), и адрес (**куда** мы записываем результат, в R1).

Для описания аргумента нужно значение (что) и адрес (куда). Поэтому определим в эмуляторе структуру для хранения аргументов:
```cpp
struct Argument {
    word value;     // значение (что)
    address adr;    // адрес (куда)
} ss, dd;
```
В этом проекте мы сделаем так, как всегда запрещали делать преподаватели. Объявим **глобальные** переменные **ss** и **dd**.

Использование любой глобальной переменной нужно обосновывать.

1. Разные команды имеют разное количество аргументов. В описании команды нужно определить указатель на функцию `do_функция`. Записать общее количество аргументов и их тип. Для простоты решим, что функции без аргументов, необходимые аргументы исполняемой команды будем брать в глобальных переменных.

2. Одновременно мы разбираем только одну команду, так что пока не выполнится одна команда, в аргументах будут лежать именно ее значения. До разбора другой команды.

3. Надо попробовать использовать глобальные переменные и узнать, почему преподаватели говорили, что их лучше не использовать. Если учиться на своих ошибках, то материал лучше запоминается.

Вопрос: зачем хранить значение? Может хватит хранить только адрес? Давайте сначала посмотрим, как получаются значения и что происходит с адресом при разборе `ss` и `dd`.

## RAM и регистры

Вспомним, как мы вводили понятие регистров, как ячеек очень быстрой памяти. К этой памяти доступ идет не через общую шину данных, а напрямую, к ней может обращаться Арифметико-Логическое Устройство (АЛУ), на котором происходит выполнение команд процессора.

![регистры](https://stepik.org/media/attachments/lesson/325592/fon_neiman.svg)

* RAM (random access memory) - память с произвольным доступом (в отличие от последовательной памяти на магнитных лентах).
* Регистры - память с малым временем доступа.
    * Общего назначения (к R0, .. , R7 обращаемся одинаково),
    * Нет формата обращения к половине регистра (нельзя "записать число 5 в старший байт регистра"),
    * R7 так же называют PC (program counter), потому что в нем лежит адрес очередного читаемого слова (команды) из памяти,
    * R6 так же называют SP (stack pointer), о нем поговорим позже.

Команда `mov` копирует данные. Копировать данные нужно:

* из регистра в регистр,
* из регистра в общую память RAM,
* из RAM в регистр,
* из RAM в RAM (по разным адресам),
* посылать данные и читать данные из внешних устройств (монитор, клавиатура).

Можно определить для каждого типа копирования свою команду (в языке Си определена функция `scanf` для считывания данных из входного потока и `printf` для вывода данных в выходной поток).

Можно определить аргументы так, чтобы описывать все взаимодействия в регистрах и памяти.

## Аргументы SS и DD
 
Регистр - основа определения аргумента. Регистров 8, чтобы закодировать номер регистра от 0 до 7 нужно 3 бита (3 бинарных цифры, от 000 до 111).

Аргументы SS и DD длиной 6 бит, последние 3 бита - номер регистра, первые 3 бита определяют как мы этот номер регистра трактуем, то есть режим (или мода) адресации. 3 бита на режим адресации, то есть этих режимов может быть 8 штук, от моды 0, до моды 7. 

![mr.png](https://stepik.org/media/attachments/lesson/325592/mr.png)

Рассмотрим команду `INC`, которое увеличивает значение аргумента на 1. Аналог - команда языка Си `++` или `+= 1`.

| Мнемоника | Opcode | NZVC | Описание | Комментарии |
|-----|----|----|----|----|
| INC d      | **0052**DD   | `***-`   | Increment                    | d=d+1        | 

В команде только один аргумент DD. 16 бит слова с командой `INC`, биты отвечающие за аргумент обозначены как `d`.

```
|15            8|7             0| - номера бит
|0|0|0|0|1|0|1|0|1|0|d|d|d|d|d|d| - содержимое бит, бинарные числа
|0|  0  |  5  |  2  |  D  |  D  | - содержимое бит, восьмеричные числа
```
то есть
```
|15            8|7             0| - номера бит
|0|0|0|0|1|0|1|0|1|0|m|m|m|r|r|r| - 3 бита на моду, 3 бита на регистр
```

Аналогично для аргумента SS, первые 3 бита кодируют моду, следующие 3 бита - номер регистра.

Команда `MOV`:

```
|15            8|7             0| - номера бит
|0|0|0|1|m|m|m|r|r|r|m|m|m|r|r|r| - содержимое бит, бинарные числа
|0|  1  |  S  |  S  |  D  |  D  | - содержимое бит, восьмеричные числа
```

