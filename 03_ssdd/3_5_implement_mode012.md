# Реализация мод 0, 1, 2

lesson = 894650

## Все моды кратко

| Мода | Обозначение | Пример | Описание |
|----|----|-----|----------|
| 0 | `R3` | `inc R3` | Значение в регистре `R3` |
| 1 | `(R3)` | `inc (R3)` | Адрес в регистре `R3` |
| 2 | `(R3)+` | `inc (R3)+` | Адрес в регистре `R3`, `R3+=2` |
| 3 | `@(R3)+` | `inc @(R3)+` | Адрес в регистре `R3` содержит адрес, `R3+=2` |
| 4 | `-(R3)` | `inc -(R3)` | `R3-=2`, Адрес в регистре `R3`  |
| 5 | `@-(R3)` | `inc -(R3)` | `R3-=2`, Адрес в регистре `R3` содержит адрес |
| 6 | `2(R3)` | `inc 2(R3)` | Сложить 2 и `R3`, это адрес |
| 7 | `@2(R3)` | `inc @2(R3)` | Сложить 2 и `R3`, по этому адресу лежит адрес |

При работе по 7 регистру, обозначения в коде ассемблера другие:

| Мода | Обозначение | Пример | Описание |
|----|----|-----|----------|
| 2 | `#3` | `mov #3, R0` | Константа 3 |
| 3 | `@#100` | `mov @#100, R0` | Значение по адресу 100 |
| 6 | `100` | `mov 100, R0` | Значение по адресу 100 |
| 7 | `@100` | `mov @100, R0` | По адресу 100 лежит адрес, по этому адресу лежит значение |

## Что делаем в этом уроке?

Мод много, времени мало. Работающий первый тест дает возможность получить хор(5) по 10 балльной шкале. Поэтому разумно реализовать сначала моды 0, 1, 2, которые напишем вместе. Далее, пока помним как работают моды, реализуем моды 3, 4, 5. Моды 6 и 7 можно оставить до последней темы - реализации вызова подпрограмм.

**Ко всем реализованным модам должны быть написаны юниттесты.**

Далее убеждаемся, что работает интеграционный тест на 2+3 и еще одни [тест на 4 моду](https://stepik.org/lesson/894646/step/6).

Тест на 2+3 должен выводит теперь трассировку с аргументами. Между аргументами запятую ставить **не нужно**.

В команде `halt` печатать содержимое всех регистров. Напишите для этого отдельную функцию `reg_dump`.

```cpp
001000 012700: mov #2 R0
001004 012701: mov #3 R1
001010 060001: add R0 R1
001002 000000: halt
r0:2 r1:5 r2:0 r3:0 r4:0 r5:0 r6:0 r7:1014
THE END!
```
Добавляем печать аргументов и печать регистров в конце программы.

Когда в регистре `R0` у нас будет 2, а в регистре `R1` будет 5, значит программа работает верно.

Видно, что в примере используются моды 0 и 2. Так как мода 2 похожа на моду 1, то реализуем сначала только моды 0, 1, 2, только для операций со словами.

## Что уже есть для разбора аргументов

Кроме массива `mem` и функций для работы с ним, у нас уже есть массив `reg`.

Рекомендуем аргументы SS и DD хранить в структуре, где хранится адрес и значение. Можете попытаться хранить только адрес, но храните такой адрес. На ваше усмотрение.

```cpp
typedef struct {
    word value;     // значение (что)
    address adr;    // адрес (куда)
} Arg ss, dd;
``` 
Тогда разбор аргументов схематично в псевдокоде:
```cpp
if (это mov?) {
    ss = get_ss(w);
    dd = get_dd(w);
    do_mov();
}
```
В PDP-11 сначала разбирается первый аргумент, потом разбирается второй аргумент. Нужно ли для SS и DD определять порядок разбора аргументов или аргументы можно разбирать в произвольном порядке? Попробуйте придумать код на ассемблере для обоснования вашей точки зрения.

Можно ли обойтись одной общей функцией? У нас и у SS, и у DD 3 бита на номер моды, 3 бита на номер регистра. Давайте напишем одну функцию
```cpp
Arg get_mr(word w);
```
которая будет получать аргумент `w`, 6 бит которого - номер моды и номер регистра. Возвращать функция будет структуру с адресом и значением.

**Функция `do_mov` должна записывать результат в память**.

## Реализация `get_mr`

На этом шаге код пишем внутри функции:

```cpp
Arg get_mr(word w)
{
    Arg res;
    // тут пишем код
    return res;
}
```
Сначала вычислим номер регистра (последние 3 бита) и номер моды (предпоследние 3 бита). Маска из трех единиц 111 (бинарное) это число 7.

```cpp
int r = w & 7;          // номер регистра
int m = (w >> 3) & 7;   // номер моды
```
**Мода 0** : Адрес - номер регистра, значение - значение регистра, тут же печатаем трассировку `R1`

```cpp
switch (m) {
    // мода 0
    case 0:
        res.adr = r;        // адрес - номер регистра
        res.val = reg[r];   // значение - число в регистре
        trace(TRACE, "R%d ", r);
        break;
   
    // мода 1
    case 1:
        res.adr = reg[r];           // в регистре адрес
        res.val = w_read(res.adr);  // по адресу - значение
        trace(TRACE, "(R%d) ", r);  
        break;
        
    // мода 2
    case 2:
        res.adr = reg[r];           // в регистре адрес
        res.val = w_read(res.adr);  // по адресу - значение
        reg[r] += 2;                // TODO: +1
        // печать разной мнемоники для PC и других регистров
        if (r == 7)
            trace(TRACE, "#%o ", res.val);
        else
            trace(TRACE, "(R%d)+ ", r);  
        break;
        
    // мы еще не дописали другие моды
    default:
        trace(ERROR, "Mode %d not implemented yet!\n", m);
        exit(1);
}
```
Потом, когда мы будем разбирать функции, которые работают не со словами, а с байтами, не `mov`, а `movb`, нужно будет читать не слово функцией `w_read`, а байт функцией `b_read`. В этих местах поставили *todo*. Многие IDE могут посвечивать и отдельно учитывать эти метки в комментариях.

Кроме того, во 2 моде у нас может быть или +2, или +1. Оставим эти разборки на следующий урок, когда будем работать с байтовыми вариантами функций. Пока запустим хотя бы первый тест.

Функции `do_mov` и `do_add` тоже простые и **короткие**. В них не должно быть никаких разборов аргументов или печати имени функции.

```cpp
void do_mov()
{
    // значение аргумента ss пишем по адресу аргумента dd
    w_write(dd.adr, ss.val);
}
void do_add()
{
    // значение аргумента ss и dd пишем по адресу аргумента dd
    w_write(dd.adr, ss.val + dd.val);
}
```
На самом деле мы такой реализации закопали грабли, на которые наступим. Чтобы наступать быстрее и понятнее, напишем юниттесты на моды адресации.