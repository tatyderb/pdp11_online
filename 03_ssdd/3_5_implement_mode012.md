# Реализация мод 0, 1, 2

lesson = 894650

## Все моды кратко

| Мода | Обозначение | Пример | Описание |
|----|----|-----|----------|
| 0 | `R3` | `inc R3` | Значение в регистре `R3` |
| 1 | `(R3)` | `inc (R3)` | Адрес в регистре `R3` |
| 2 | `(R3)+` | `inc (R3)+` | Адрес в регистре `R3`, `R3+=2` |
| 3 | `@(R3)+` | `inc @(R3)+` | Адрес в регистре `R3` содержит адрес, `R3+=2` |
| 4 | `-(R3)` | `inc -(R3)` | `R3-=2`, Адрес в регистре `R3`  |
| 5 | `@-(R3)` | `inc -(R3)` | `R3-=2`, Адрес в регистре `R3` содержит адрес |
| 6 | `2(R3)` | `inc 2(R3)` | Сложить 2 и `R3`, это адрес |
| 7 | `@2(R3)` | `inc @2(R3)` | Сложить 2 и `R3`, по этому адресу лежит адрес |

При работе по 7 регистру, обозначения в коде ассемблера другие:

| Мода | Обозначение | Пример | Описание |
|----|----|-----|----------|
| 2 | `#3` | `mov #3, R0` | Константа 3 |
| 3 | `@#100` | `mov @#100, R0` | Значение по адресу 100 |
| 6 | `100` | `mov 100, R0` | Значение по адресу 100 |
| 7 | `@100` | `mov @100, R0` | По адресу 100 лежит адрес, по этому адресу лежит значение |

## Что делаем в этом уроке?

Мод много, времени мало. Работающий первый тест дает возможность получить хор(5) по 10 балльной шкале. Поэтому разумно реализовать сначала моды 0, 1, 2, которые напишем вместе. Далее, пока помним как работают моды, реализуем моды 3, 4, 5. Моды 6 и 7 можно оставить до последней темы - реализации вызова подпрограмм.

**Ко всем реализованным модам должны быть написаны юниттесты.**

Далее убеждаемся, что работает интеграционный тест на 2+3 и еще одни [тест на 4 моду](https://stepik.org/lesson/894646/step/6).

Тест на 2+3 должен выводит теперь трассировку с аргументами. Между аргументами запятую ставить **не нужно**.

В команде `halt` печатать содержимое всех регистров. Напишите для этого отдельную функцию `reg_dump`.

```cpp
001000 012700: mov #2 R0
001004 012701: mov #3 R1
001010 060001: add R0 R1
001002 000000: halt
r0:2 r1:5 r2:0 r3:0 r4:0 r5:0 r6:0 r7:1014
THE END!
```
Добавляем печать аргументов и печать регистров в конце программы.

Когда в регистре `R0` у нас будет 2, а в регистре `R1` будет 5, значит программа работает верно.

Видно, что в примере используются моды 0 и 2. Так как мода 2 похожа на моду 1, то реализуем сначала только моды 0, 1, 2, только для операций со словами.

## Только halt

Прежде, чем делать большие изменения, убедимся, что функция без аргументов работает. Это программа, состоящая из одной команды
```cpp
.=1000
halt
```
Исполняемый модуль:
```cpp
200 2
0
0
```
Трассировка (уже добавили печать регистров)
```cpp
001000 000000: halt
r0:0 r1:0 r2:0 r3:0 r4:0 r5:0 r6:0 r7:1002
THE END!
```
**Задание**: Убедитесь, что такой тест работает.

## Что уже есть для разбора аргументов

Кроме массива `mem` и функций для работы с ним, у нас уже есть массив `reg`.

Рекомендуем аргументы SS и DD хранить в структуре, где хранится адрес и значение. Можете попытаться хранить только адрес. На ваше усмотрение.

```cpp
typedef struct {
    word value;     // значение (что)
    address adr;    // адрес (куда)
} Arg ss, dd;
``` 
Тогда разбор аргументов схематично в псевдокоде:
```cpp
if (это mov?) {
    ss = get_ss(w);
    dd = get_dd(w);
    do_mov();
}
```
В PDP-11 сначала разбирается первый аргумент, потом разбирается второй аргумент. Нужно ли для SS и DD определять порядок разбора аргументов или аргументы можно разбирать в произвольном порядке? Попробуйте придумать код на ассемблере для обоснования вашей точки зрения.

Можно ли обойтись одной общей функцией? У нас и у SS, и у DD 3 бита на номер моды, 3 бита на номер регистра. Давайте напишем одну функцию
```cpp
Arg get_mr(word w);
```
которая будет получать аргумент `w`, 6 бит которого - номер моды и номер регистра. Возвращать функция будет структуру с адресом и значением.

**Функция `do_mov` должна записывать результат в память**.

## Реализация `get_mr`

На этом шаге код пишем внутри функции:

```cpp
Arg get_mr(word w)
{
    Arg res;
    // тут пишем код
    return res;
}
```
Сначала вычислим номер регистра (последние 3 бита) и номер моды (предпоследние 3 бита). Маска из трех единиц 111 (бинарное) это число 7.

```cpp
int r = w & 7;          // номер регистра
int m = (w >> 3) & 7;   // номер моды
```
* **Мода 0** : Адрес - номер регистра, значение - значение регистра, тут же печатаем трассировку `R1`
* **Мода 1** : Адрес - лежит в регистре, значение читаем в памяти по этому адресу, тут же печатаем трассировку `(R1)`
* **Мода 2** : То же, что мода 1, но +2 к значению регистра в конце. Трассировка  `(R1)+` или `#3`

```cpp
switch (m) {
    // мода 0, R1
    case 0:
        res.adr = r;        // адрес - номер регистра
        res.val = reg[r];   // значение - число в регистре
        trace(TRACE, "R%d ", r);
        break;
   
    // мода 1, (R1)
    case 1:
        res.adr = reg[r];           // в регистре адрес
        res.val = w_read(res.adr);  // по адресу - значение
        trace(TRACE, "(R%d) ", r);  
        break;
        
    // мода 2, (R1)+ или #3
    case 2:
        res.adr = reg[r];           // в регистре адрес
        res.val = w_read(res.adr);  // по адресу - значение
        reg[r] += 2;                // TODO: +1
        // печать разной мнемоники для PC и других регистров
        if (r == 7)
            trace(TRACE, "#%o ", res.val);
        else
            trace(TRACE, "(R%d)+ ", r);  
        break;
        
    // мы еще не дописали другие моды
    default:
        trace(ERROR, "Mode %d not implemented yet!\n", m);
        exit(1);
}
```
Потом, когда мы будем разбирать функции, которые работают не со словами, а с байтами, не `mov`, а `movb`, нужно будет читать не слово функцией `w_read`, а байт функцией `b_read`. В этих местах поставили *todo*. Многие IDE могут посвечивать и отдельно учитывать эти метки в комментариях.

Кроме того, во 2 моде у нас может быть или +2, или +1. Оставим эти разборки на следующий урок, когда будем работать с байтовыми вариантами функций. Пока запустим хотя бы первый тест.

Функции `do_mov` и `do_add` тоже простые и **короткие**. В них не должно быть никаких разборов аргументов или печати имени функции.

```cpp
void do_mov()
{
    // значение аргумента ss пишем по адресу аргумента dd
    w_write(dd.adr, ss.val);
}
void do_add()
{
    // сумму значений аргументов ss и dd пишем по адресу аргумента dd
    w_write(dd.adr, ss.val + dd.val);
}
```
На самом деле мы такой реализации закопали грабли, на которые наступим. Чтобы наступать быстрее и понятнее, напишем юниттесты на моды адресации.

## Тест для моды 0

Давайте подумаем, как было бы удобно проверить работу одной моды. Желательно, сделать проверку автоматическую, а не проверять правильность напечатанного текста.

```cpp
mov R5, R3
```
и проверить, правильно ли прошло копирование данных.

Для такого теста удобно выделить в отдельную функцию `parse_cmd` один шаг основного цикла выполнения программы. Быть может даже с чтением слова по адресу `pc` и печати части трассировки в функции `read_cmd`:
```cpp
Command cmd;
while(1) {
    cmd = parse_cmd(read_cmd()); // читаем слово и разбираем команду
    cmd.do_command();            // выполняем команду
}
```
Мы еще на этапе поиска какая команда закодирована, могли бы написать тесты на правильность разбора команды.

В тесты не забудьте добавить печать названия теста и статус теста ОК.

```cpp
// тест, что мы правильно определяем команды mov, add, halt
void test_parse_mov()
{
    trace(TRACE, __FUNCTION__);
    Command cmd = parse_cmd(0017654);
    assert(strcmp(cmd.name, "mov");
    trace(TRACE, " ... OK\n");
}
// тест, что мы разобрали правильно аргументы ss и dd в mov R5, R3 
void test_mode0()
{
    trace(TRACE, __FUNCTION__);
    reg[3] = 12;    // dd
    reg[5] = 34;    // ss
    Command cmd = parse_cmd(0010503);
    assert(ss.val == 34);
    assert(ss.adr == 5);
    assert(dd.val == 12);
    assert(dd.adr == 3);
    trace(TRACE, " ... OK\n");
}
// тест, что mov и мода 0 работают верно в mov R5, R3
 void test_mov()
{
    trace(TRACE, __FUNCTION__);
    reg[3] = 12;    // dd
    reg[5] = 34;    // ss
    Command cmd = parse_cmd(0010503);
    cmd.do_command();
    assert(reg[3] = 34);
    assert(reg[5] = 34);
    trace(TRACE, " ... OK\n");
}   
```

Эти тесты можно выполнять до или вместо загрузки и выполнения программы. Например, запуск эмулятора с ключом `--testall` запускает все тесты, а с ключом `--testone` один конкретный тест. То есть вы отлаживаете очередной тест (запуск одиночного теста), добавляете его в набор всех тестов и запускаете все тесты, нужно убедиться, что вы не сломали старый код.

**Задание**: написать тесты для разбора и выполнения моды 0. Добиться их работоспособности.

Код, который мы написали - основа. Он не будет работать. Его нужно изменить так, чтобы команды работали.

Прежде чем идти дальше, попробуйте найти в чем проблема и решить её.

## Работа над ошибками

На предыдущем шаге вы должны были обнаружить, что при 0 моде в поле адреса аргумента записан номер **регистра**, а функция `w_write` трактует этот номер, как адрес в **памяти**.

Надеемся, что вы это обнаружили, из-за диагностики в `w_write` "запись слова по нечетному адресу". Если нет, то добавьте `assert` в функции работы со словами.

Давайте обсудим, как можно починить этот баг (ошибку).

### Пространство адресов

Первое, что приходит в голову, передавать в функцию `w_write` и остальные еще и к чему относится адрес - к памяти или к регистрам.

Такое же поле добавить в структуру, описывающую аргументы SS и DD.

```cpp
#define REGSPACE 1
#define MEMSPACE 0

void w_write(address adr, word val, int reg_space)
{
    if (reg_space) {
        reg[adr] = val;
        return;
    }
    // дальше прежний код
}
```

### Особые правила работы с первыми 8 байтами

Предыдущий вариант - это честная эмуляция.

Можно попытаться "срезать углы". Давайте считать, что по первым 8 байтам в памяти не лежит ничего важного для нашей программы. В реальности там лежит операционная система. Но мы остановимся в реализации эмулятора раньше, потому что для реализации некоторых команд нужно уметь писать асинхронный код, а это явно не "моя первая большая программа".

Считаем, что если мы пишем или читаем по адресу с 0 по 7, то мы пишем и читаем в регистры.

```cpp
void w_write(address adr, word val)
{
    if (adr < 8) {
        reg[adr] = val;
        return;
    }
    // дальше прежний код
}
```

Читерство, но преподаватель его разрешил.

Возможно, у вас перестали работать тесты на функции работы с памятью. Почините их, прежде чем идти дальше.

**Набор тестов всегда должен быть в актуальном состоянии**.

## Тесты для моды 1

```cpp
mov (R5), R3
```
Надо разложить заранее данные (фаза теста setup) и проверить, правильно ли прошло копирование данных.

В конце группы тестов или одного теста надо очистить данные от "мусора", привнесенного тестом. Эта фаза в тестировании называется teardown или cleanup (уборка).

Можете совместить тестирование разбора аргументов и работы команды. Такие тесты проще разрабатывать (меньше писать), но сложнее отлаживать код (можем наступить сразу на много ошибок).
```cpp
// тест, что мы разобрали правильно аргументы ss и dd в mov (R5), R3 
void test_mode1_toreg()
{
    trace(TRACE, __FUNCTION__);
    
    // setup
    reg[3] = 12;    // dd
    reg[5] = 0200;  // ss
    w_write(0200, 34);    
    
    Command cmd = parse_cmd(0011503);
    
    assert(ss.val == 34);
    assert(ss.adr == 0200);
    assert(dd.val == 12);
    assert(dd.adr == 3);
    
    cmd.do_command();
    
    assert(reg[3] = 34);
    // проверяем, что значение регистра не изменилось
    assert(reg[5] = 0200);  

    trace(TRACE, " ... OK\n");
}
```
Желательно сразу же написать тест для моды 1, когда мы не только читаем из памяти, но и пишем в неё. Это тест вида "из регистра в память" `mov R3, (R5)` или "из памяти в память" `mov (R5), (R3)`.

**Задание**: напишите еще один тест на моду 1, чтобы была запись в память и отладьте код, если нужно.

## Тест для моды 2

Напишите тест для моды 2 самостоятельно.

После его отладки возьмите программу, которая считает 2+3 и запустите её. Если тесты написаны хорошо, ваша первая программа на ассемблере заработает. Могут быть проблемы с форматом трассировки, поправьте их.

**Поздравляем! Ваша первая программа на эмуляторе успешно заработала!**

Студенты МФТИ, если на календаре май, то стоит подумать, что 5(хорошо) - это *хорошая* оценка, пойти сдавать зачет и перенести усилия на  математику и физику.
