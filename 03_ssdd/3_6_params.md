# Какие аргументы?

lesson = 536176

## Проблема

Мы писали разбор команд, разбирая для всех команд аргументы SS и DD.

```cpp
if (это mov?) {
    ss = get_ss(w);
    dd = get_dd(w);
    do_mov();
}
```

Переписали этот код в виде цикла:
```cpp
if (это очередная команда?) {
    ss = get_ss(w);
    dd = get_dd(w);
    do_эта_команда();
}
```
Если мы посмотрим на [таблицу команд](https://stepik.org/lesson/347539/step/1), то увидим, что аргументы отдельные команды имеют аргументы R, N, NN, XX. Подумайте, можно ли аналогично сделать глобальные переменные и писать так, если вы знаете, что R и N - это 3 бита, NN - 6 бит, XX - 8 бит (число со знаком + или -): 
```cpp
if (это очередная команда?) {
    ss = get_ss(w);
    dd = get_dd(w);
    r = get_r(w);
    n = get_n(w);
    nn = get_nn(w);
    xx = get_xx(w);
    do_эта_команда();
}
```

## Надо разбирать только свои аргументы

С другими типами аргументов это будет работать, но не с SS и DD. Рассмотрим команду с опкодом 0052DD:
```cpp
INC R1; 005201 - увеличить значение регистра R1 на 1
```
Но если мы будем выполнять код разбора SS, то это разбор числа 52 из опкода, то есть 5 мода по 2 регистру, а это изменение значения регистра `R2`. То есть разбор команды и аргументов *ошибочно* изменяет другие данные.

Значит, нужно разбирать только те аргументы, что есть у команды. Как это сделать, если мы свернули разбор команды в цикл и описываем каждую команду в массиве структур типа `Command`?

```cpp
if (это очередная команда?) {
    if (у команды есть SS?)
        ss = get_ss(w);
    if (у команды есть DD?)
        dd = get_dd(w);
    ...
    do_эта_команда();
}
```

* перенесем разбор аргументов в `do_mov`, `do_add` и тп. Плохо, идет копирование одинакового кода.
* развернем цикл в множество if и будем писать для каждой команды свои аргументы. Еще хуже. И да, копирование одинакового кода.
* закодируем признаки какой аргумент есть в полях структуры `Command`.

```cpp
typedef struct {
    word mask;
    word opcode;
    char * name;
    (void *)do_command(void);
    char has_ss;    // 0 или 1 - нет или есть аргумент SS
    char has_dd;    // 0 или 1
    char has_nn;    // 0 или 1
    char has_xx;    // 0 или 1
    // и так далее
} Command;
```
Плохо, потому что на кодирование 1 бита 0 или 1 тратится 8 бит. И очень легко ошибиться, когда пытаешься написать, что у команды есть только аргумент NN при такой записи:
```cpp
Command command[] = {
    {0170000, 0010000, "mov", do_mov, 1, 1, 0, 0},
    ...
}
```
Для экономии можно использовать битовые поля в структурах. Но явная инициализация в массиве структур от этого не станет более читаемой.

## Битовые флаги

Вспомним [задачу](https://stepik.org/lesson/305206/step/3), где в одном байте в разных битах были закодированы разные признаки человека (пол, умный или нет, носит ли шляпу, цвет волос, глаз и тп).

Так же в 1 байте закодируем есть или нет в одной команде (например, в команде `mov`) аргументы типа SS, DD, NN, XX и так далее, по 1 биту на признак - есть такой аргумент или нет:

![params.png](https://stepik.org/media/attachments/lesson/536176/params.png)

Добавим в структуру описания команд поле `params` и будем придерживаться указанного формата трактовки его бит.

```cpp
typedef struct {
word mask;
word opcode;
char * name;
char params;    // в 1 байте кодируем наличие разных типов аргументов
} Command;
```
Инициализация:
```cpp
Command command[] = {
    {0170000, 0010000, "mov", do_mov, 3},
    ...
}
```
Маска и опкод так и должны задаваться, но "магическое число" 3 - это очень плохой стиль программирования. Лучше сделать именнованые константы:
```cpp
#define NO_PARAMS 0
#define HAS_DD 1
#define HAS_SS 2
``` 
Тогда описание команды `mov`:
```cpp
Command command[] = {
    {0170000, 0010000, "mov", do_mov, HAS_SS | HAS_DD},
    ...
}
```
Проверку, содержит ли `HAS_SS` поле `params` напишите сами. Посмотрите, какой получился красивый и читаемый код.

**Задание**: допишите кодирование параметров каждой команды. Отладьте код и проверьте, что тест на 2+3 работает.

## Моды 3, 4, 5

Задание:

* Реализуйте моды 3, 4, 5; к каждой моде дописывайте хотя бы по одному тесту.
* Запустите тест [04_mode4](https://github.com/tatyderb/pdp11_tests/tree/master/04_mode4), если нужно, отладьте код.
* Подумайте, как написать юниттест, который бы проверял, что изменение регистров в моде 4 происходит в нужное время.
