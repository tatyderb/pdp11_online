# Передача аргументов в функцию

lesson = 320753

## SKIP VIDEO Видео: передача аргументов через фрейм (Fortran)

https://youtu.be/BUVvgXoufuA

## SKIP VIDEO Видео: передача аргументов через стек (Pascal)

https://youtu.be/leITeZJS05Q

## SKIP VIDEO Видео: передача аргументов через стек (C)

https://youtu.be/6UN0kB5HHNE

## Передача аргументов по-студенчески

В наших тестах мы будем передавать аргументы в функции "по-студенчески". То есть будем договариваться, что в этой функции в регистре `R0` мы ожидаем ascii-код символа, а в этой функции в `R1` - адрес начала строки.

Все такие "аргументы" мы будем тщательно документировать в шапке комментарии к функции.

Именно так будет написан тест Hello, world с функциями [10_jsr_rts](https://github.com/tatyderb/pdp11_tests/blob/master/10_jsr_rts/10_jsr_rts.pdp)

```cpp
ostat = 177564
odata = 177566

	.=200
STR: .ASCIZ /Hello, world!/

; R0 - адрес очередного символа
; R1 - значение ascii кода этого символа (число)

	.=1000
main:
	mov #main, sp
	mov #STR, R1
	jsr	pc, puts
	halt
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; puts - print string up to 0
;   R1 - string address
; corrupted:
;   R0
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
puts:	
	movb 	(R1)+, R0
	beq 	ENDputs
	jsr		pc, putc
	br		puts
ENDputs:
	rts		pc

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; putc - print 1 character from R0
;   R0 - ascii code
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
putc:
	tstb	@#ostat
	bpl		putc
	movb	R0, @#odata
	rts 	pc
	
	halt
```

Очень трудно так программировать. Если `R0` нужно для `putc`, то он должен быть использован внутри `puts` и значит аргумент для `puts` нужно класть уже в другой регистр. `R2` - нужен для возврата из функций.

У нас скоро закончатся все регистры. И что делать, если в функцию надо передать много аргументов?

Есть несколько способов организации передачи аргументов. Их до сих пор используют в разных языках. Далее мы разберем эти способы.

## Передача аргументов через фрейм (Fortran)

Идея: положим аргументы в коде программы сразу же после вызова `jsr`. Организуем так называемый "фрейм данных". Этот способ используется в языке программирования Фортран.

Пусть функция `putsn` печатает строку, не более `n` символов. У нее два аргумента - адрес начала строки и `n` - сколько символов надо печатать. Как передать эти аргументы?

После `jsr R2, putsn` с помощью псевдокоманд `.WORD` кладется 2 аргумента. Адрес начала строки и количество символов.

Сначала напишем код одним фрагментом, потом разберем подробно его по частям.
```cpp
1000:    jsr R2, putsn   ; положим аргументы сразу за вызовом функции
1004:    .WORD str       ; адрес начала строки
1006:    .WORD n         ; количество аргументов
1010:    следующая команда, по этому адресу нужно вернуться. 
...
     putsn:
2020:   mov R0, -(SP)   ; сохранили R0, stack: [R2_old, R0_old]
2022:   mov R1, -(SP)   ; сохранили R1, stack: [R2_old, R0_old, R1_old]
2024:   mov (R2)+, R0   ; первый аргумент положили в R0, 
                        ; R2 указывает на второй аргумент  
2026:   mov (R2)+, R1   ; второй аргумент положили в R1, 
                        ; R2 указывает на нужный адрес возврата
...
2040:   mov (SP)+, R1   ; из стека достали R1_old, stack: [R2_old, R0_old]
2042:   mov (SP)+, R0   ; из стека достали R0_old, stack: [R2_old]
2044:   rts R2          ; переходим по адресу, хранящемуся в R2, 
                        ; восстанавливаем R2=R2_old, stack: []
```

Начинается вызов функции и раскладываются аргументы.

```cpp
1000:    jsr R2, putsn   ; положим аргументы сразу за вызовом функции
1004:    .WORD str       ; адрес начала строки
1006:    .WORD n         ; количество аргументов
1010:    следующая команда, по этому адресу нужно вернуться. 
``` 
Заметим, что адрес возврата у нас вычисляется неверно, `jsr` считает, что вернуться нужно по адресу 1004 (ибо команда занимает 2 слова). То есть `R2=1004`. Но по этому адресу у нас первый аргумент. Адрес возврата должен быть 1010.

В стеке после вызова `jsr` лежит старое значение `R2`, обозначим его `R2_old`.

`stack: [R2_old]`

Разбором фрейма и коррекцией адреса возврата мы займемся внутри функции `putsn`.

```cpp
     putsn:
2020:   mov R0, -(SP)   ; сохранили R0, stack: [R2_old, R0_old]
2022:   mov R1, -(SP)   ; сохранили R1, stack: [R2_old, R0_old, R1_old]
```
Сейчас `R2=1004` - следующее слово после `jsr`. Там лежит первый аргумент. Прочитаем аргумент в `R0`, сдвинем `R2` на следующее слово, чтобы скорректировать адрес возврата.

```cpp
2024:   mov (R2)+, R0   ; первый аргумент положили в R0, 
                        ; R2 указывает на второй аргумент  
```
Сейчас `R2=1006`. Там лежит второй аргумент. Прочитаем аргумент в `R1`, сдвинем `R2` на следующее слово, чтобы скорректировать адрес возврата.
```cpp
2026:   mov (R2)+, R1   ; второй аргумент положили в R1, 
                        ; R2 указывает на нужный адрес возврата
```
Далее выполняем функцию и переходим к коду возврата из функции. Заметим, восстанавливаем из стека в обратном порядке. Если клали сначала `R0_old`, потом `R1_old`, то достаем из стека сначала `R1_old`, потом `R0_old`:
```cpp
2040:   mov (SP)+, R1   ; из стека достали R1_old, stack: [R2_old, R0_old]
2042:   mov (SP)+, R0   ; из стека достали R0_old, stack: [R2_old]
2044:   rts R2          ; переходим по адресу, хранящемуся в R2, 
                        ; восстанавливаем R2=R2_old, stack: []
```

## Передача аргументов через стек (Pascal)

Идея: в коде программы **перед** вызовом функции положим аргументы в стек. Этот способ используется в языке программирования Паскаль.

Пусть функция `putsn` печатает строку, не более `n` символов. У нее два аргумента - адрес начала строки и `n` - сколько символов надо печатать. Как передать эти аргументы?

Перед `jsr R2, putsn` с помощью `mov` в стек кладется 2 аргумента. Адрес начала строки str и количество символов n.

Сначала напишем код одним фрагментом, потом разберем подробно его по частям.
```cpp
1000:    mov #str, -(SP) ; stack: [return, str]
1002:    mov #n, -(SP)   ; stack: [return, str, n]
1004:    jsr PC, putsn   ; R2=1010, stack: [return, str, n, 1010]
1010:    следующая команда, по этому адресу нужно вернуться. 
...
     putsn:
2020:   mov R0, -(SP)   ; сохранили R0, stack: [R2_old, R0_old]
2022:   mov R1, -(SP)   ; сохранили R1, stack: [R2_old, R0_old, R1_old]
2024:   mov 10(SP), R0  ; R0 = str
2030:   mov 6(SP), R1   ; R1 = n
...
2040:   mov (SP)+, R1   ; из стека достали R1_old, stack: [return, str, n, 1010, R0_old]
2042:   mov (SP)+, R0   ; из стека достали R0_old, stack: [return, str, n, 1010]
2044:   mov (sp)+, 2(SP); stack: [return, 1010, n]
2050:   add #2, SP      ; сдвинули SP,  stack: [return, 1010] 
2054:   rts PC          ; переходим по адресу, хранящемуся в стеке, stack: [return]
```

Положим аргументы перед вызовом в стек, изначально считаем, что в стеке хранится **адрес возврата из другой функции, который нельзя потерять**. Обозначим его `return`
```cpp
1000:    mov #str, -(SP) ; stack: [return, str]
1002:    mov #n, -(SP)   ; stack: [return, str, n]
1004:    jsr PC, putsn   ; R2=1010, stack: [return, str, n, 1010]
1010:    следующая команда, по этому адресу нужно вернуться. 
``` 
Заметим, что адрес возврата у нас вычисляется верно.

Указывать какой-то регистр для `jsr` нам нужно только при организации передачи аргументов через фрейм. Во всех других случаях можно указать `PC` как регистр для `jsr` и `rts`. Мы [уже разбирали](https://stepik.org/lesson/320752/step/9) как работают команды в этом случае.

То есть команда `jsr PC, putsn` кладет в стек число 1010 - адрес возврата на следующую команду.

Так же как в фрейме, в начале функции сохраняем старые значения регистров в стек:
```cpp
     putsn:
2020:   mov R0, -(SP)   ; сохранили R0, stack: [return, str, n, 1010, R0_old]
2022:   mov R1, -(SP)   ; сохранили R1, stack: [return, str, n, 1010, R0_old, R1_old]
```
![стек](https://stepik.org/media/attachments/lesson/320750/call_stack.png)

Заметим, что `SP` указывает на последнюю ячейку с данными, то есть на `R1_old`. Чтобы добраться до аргументов `n` и `str` нужно сдвинуться в сторону больших адресов на 3 и 4 слова, то есть на 6 и 10 байтов (система все еще восьмеричная!)

Поэтому код добычи из стека и записи в регистры `R0` и `R1` аргументов `n` и `str` выглядит так:
```cpp
2024:   mov 10(SP), R0  ; R0 = str
2030:   mov 6(SP), R1   ; R1 = n
```

**Содержимое стека и значение SP при этом не изменяется**.

Далее выполняем функцию и переходим к коду возврата из функции. Заметим, восстанавливаем из стека в обратном порядке. Если клали сначала `R0_old`, потом `R1_old`, то достаем из стека сначала `R1_old`, потом `R0_old`:
```cpp
2040:   mov (SP)+, R1   ; из стека достали R1_old, stack: [return, str, n, 1010, R0_old]
2042:   mov (SP)+, R0   ; из стека достали R0_old, stack: [return, str, n, 1010]
```
Казалось бы, можно написать `rts PC`, вернуться по адресу, лежащему в стеке и все хорошо. Но у нас до того, как мы начали формировать аргументы и переходить в функции, **на вершине стека** лежал очень важный адрес возврата, который мы обозначали `return`. После работы наших функций он тоже должен стать на вершине стека, иначе цепочка возвратов из функций сломается.

Надо сделать так, чтобы `return` стало лежать на вершине стека. Для этого адрес возврата 1010 копируем на место `str` в стеке. 
```cpp
2044:   mov (sp)+, 2(sp); stack: [return, 1010, n]
```
Теперь адрес возврата 1010 на месте, сразу после `return`. Но `SP` содержит адрес вершины на 2 меньше, чем нужно и указывает на `n`. Увеличим `SP` на 2. Это команда `add #2, SP` (занимает 2 слова) или более короткий вариант `tst (SP)+` (занимает одно слово). Для понятности кода запишем вариант с `add`:

```cpp
2046:   add #2, SP      ; stack: [return, 1010]
```

Теперь можно вернуться из функции
```cpp
2046:   rts PC          ; переходим по адресу, хранящемуся в стеке, stack: [return]
```

## Передача аргументов через стек (Си)

Идея: передача аргументов через стек такая же, как в Паскале, но зачистка стека происходит не перед возвратом, а после возврата. Это первая команда после возврата из функции.

в коде программы **перед** вызовом функции положим аргументы в стек. Этот способ используется в языке программирования Си.

Пусть функция `putsn` печатает строку, не более `n` символов. У нее два аргумента - адрес начала строки и `n` - сколько символов надо печатать. Как передать эти аргументы?

Перед `jsr R2, putsn` с помощью `mov` в стек кладется 2 аргумента. Адрес начала строки str и количество символов n.

Сначала напишем код одним фрагментом, потом разберем подробно его по частям.
```cpp
1000:   mov #str, -(SP) ; stack: [return, str]
1002:   mov #n, -(SP)   ; stack: [return, str, n]
1004:   jsr PC, putsn   ; R2=1010, stack: [return, str, n, 1010]
1010:   следующая команда, по этому адресу нужно вернуться. 
1010:   add #4, SP      ; stack: [return] Б\<-- Зачистка стека здесь
...
     putsn:
2020:   mov R0, -(SP)   ; сохранили R0, stack: [R2_old, R0_old]
2022:   mov R1, -(SP)   ; сохранили R1, stack: [R2_old, R0_old, R1_old]
2024:   mov 10(SP), R0  ; R0 = str
2030:   mov 6(SP), R1   ; R1 = n
...
2040:   mov (SP)+, R1   ; из стека достали R1_old, stack: [return, str, n, 1010, R0_old]
2042:   mov (SP)+, R0   ; из стека достали R0_old, stack: [return, str, n, 1010]
2044:   rts PC          ; переходим по адресу, хранящемуся в стеке, stack: [return]
```

Положим аргументы перед вызовом в стек, изначально считаем, что в стеке хранится **адрес возврата из другой функции, который нельзя потерять**. Обозначим его `return`
```cpp
1000:    mov #str, -(SP) ; stack: [return, str]
1002:    mov #n, -(SP)   ; stack: [return, str, n]
1004:    jsr PC, putsn   ; R2=1010, stack: [return, str, n, 1010]
1010:    следующая команда, по этому адресу нужно вернуться. 
``` 
Заметим, что адрес возврата у нас вычисляется верно.

То есть команда `jsr PC, putsn` кладет в стек число 1010 - адрес возврата на следующую команду.

В начале функции сохраняем старые значения регистров в стек:
```cpp
     putsn:
2020:   mov R0, -(SP)   ; сохранили R0, stack: [return, str, n, 1010, R0_old]
2022:   mov R1, -(SP)   ; сохранили R1, stack: [return, str, n, 1010, R0_old, R1_old]
```
![стек](https://stepik.org/media/attachments/lesson/320750/call_stack.png)

Заметим, что `SP` указывает на последнюю ячейку с данными, то есть на `R1_old`. Чтобы добраться до аргументов `n` и `str` нужно сдвинуться в сторону больших адресов на 3 и 4 слова, то есть на 6 и 10 байтов (система все еще восьмеричная!)

Поэтому код добычи из стека и записи в регистры `R0` и `R1` аргументов `n` и `str` выглядит так:
```cpp
2024:   mov 10(SP), R0  ; R0 = str
2030:   mov 6(SP), R1   ; R1 = n
```

**Содержимое стека и значение SP при этом не изменяется**.

Далее выполняем функцию и переходим к коду возврата из функции. Заметим, восстанавливаем из стека в обратном порядке. Если клали сначала `R0_old`, потом `R1_old`, то достаем из стека сначала `R1_old`, потом `R0_old`:
```cpp
2040:   mov (SP)+, R1   ; из стека достали R1_old, stack: [return, str, n, 1010, R0_old]
2042:   mov (SP)+, R0   ; из стека достали R0_old, stack: [return, str, n, 1010]
```
Теперь можно вернуться из функции
```cpp
2044:   rts PC          ; переходим по адресу, хранящемуся в стеке, stack: [return, str, n]
```
Мы уже на адресе 1010, но у нас на вершине стека лежит не очень важный код возврата `return`, а "мусор" - аргументы `str` и `n`.

Зачистим стек так, чтобы на вершине стека лежал `return`. Для этого достаточно `SP` передвинуть на 2 слова больше.

```cpp
1010:   add #4, SP      ; stack: [return]
```
