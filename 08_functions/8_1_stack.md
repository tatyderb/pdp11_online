# Стек программный и аппаратный

lesson = 320750

## SKIP VIDEO Полное видео

https://youtu.be/DWjPbAy74B0

## SKIP VIDEO Видео: стек программный и аппаратный

https://youtu.be/rfxY_aCu4ko

## Задача урока

* Уже умеем печатать `Hello, world!`, теперь сделаем это с помощью функций.
* Разберем передачу аргументов в функцию. Это не требует дополнительного кода в эмуляторе, но поможет вам понять, как на более низком уровне организована передача аргументов и возврат значения из функции. Что такое стек вызова функций.

## Cтек

Стек - структура данных, в которой реализован принцип **LIFO** (last input, first output), последним пришел, первым ушел. 

Пример стека - стопка тарелок или книг, детская пирамидка из колец, вагон метро в час пик. Тарелку можно поставить только на верх стопки и снять тоже - только верхнюю тарелку. Нельзя выдернуть тарелку из середины.

<img src="https://stepik.org/media/attachments/lesson/300286/toy.png"/> 
<img src="https://stepik.org/media/attachments/lesson/300286/stones.jpg"/> 

Основа интерфейса - это метод **push** (добавить элемент на вершину стека) и **pop** (удалить элемент с вершины стека).

<img src="https://stepik.org/media/attachments/lesson/300286/push_pop.png"/> 

## Программный стек

Стек в ассемблере можно реализовать с помощью команды `MOV` и мод адресации.

Покажем пример стека на основе регистра `R3`. В регистре хранится адрес первой **пустой** ячейки, куда можно положить данные.

Пусть изначально `R3` указывал на адрес 2410:
```cpp
mov #2410, R3;  R3 = 2410
```
Кладем данные в стек (push):

```cpp
mov #17, (R3)+  ; положили в стек число 17
mov R1, (R3)+   ; положили в стек значение регистра R1
mov ADR, (R3)+  ; положили в стек число по адресу ADR
``` 
Обозначим на рисунке `c(R1)` - содержимое регистра `R1`, `c(ADR)` - слово в памяти по адресу `ADR`:

![стек в сторону больших адресов](https://stepik.org/media/attachments/lesson/320750/stack_plus.png)

Достаем данные из стека (pull):
```cpp
mov -(R3), R4
```
Стек реализован с помощью 2 и 4 моды адресации. Он растет в сторону больших адресов. Можно на тех же модах реализовать стек, растущий в сторону меньших адресов.

## Программный стек (рост в сторону меньших адресов)

Возьмем тот же регистр `R3`:
```cpp
mov #2410, R3;  R3 = 2410
```
Кладем данные в стек (push):

```cpp
mov #17, -(R3)  ; положили в стек число 17
mov R1, -(R3)   ; положили в стек значение регистра R1
mov ADR, -(R3)  ; положили в стек число по адресу ADR
``` 

![стек в сторону меньших адресов](https://stepik.org/media/attachments/lesson/320750/stack_minus.png)

Достаем данные из стека (pull):
```cpp
mov (R3)+, R4
```
В регистре `R3` содержится адрес последней ячейки с данными.

Те же моды адресации, стек растет в другую сторону.

## Доступ внутрь стека (индексная мода адресации)

По правилу работы со структурой данных "стек" мы кладем строго на вершину стека и берем строго с вершины. Внутрь не лезем. Но вы увидите дальше, что нам будет удобно брать числа не с вершины стека. Для этого можно использовать индексную моду адресации (она же мода 6).

Пусть регистр `R1` содержит адрес верхушки стека, число 2410 (адрес последних положенных данных, если стек рос в сторону меньших адресов). 

Специально взяли другой регистр, чтобы вы почувствовали, что **программный стек** можно организовать на любом регистре (кроме PC).

Хотим найти сумму всех чисел в стеке, не изменяя его. И положить сумму в регистр `R0`.

Индексная мода *n(Ri)* к содержимому регистра *Ri* прибавляет число *n* и это трактуется как *адрес*. То есть если в `R1` адрес начала массива, то `(R1)` - значение его нулевого элемента, то есть первая мода - это индексная с индексом 0.

Следующее слово в этом массиве лежит по адресу `2(R1)`. В языке Си мы привыкли для массива `a` получить элемент с индексом 2 как `a[2]`, а в ассемблере 2 пишется перед номером регистра.

Просуммируем 3 числа из стека. Специально берем числа в произвольном порядке:
```cpp
clr R5          ; обнулили регистр с суммой
add 6(R1), R5   ; R5 += 6066 (это мода 6)
add (R1), R5    ; R5 += 4022 (это мода 1)    
add 2(R1), R5   ; R5 += 17763 (это мода 6)
```

![индексная мода](https://stepik.org/media/attachments/lesson/320750/stack_in.png)

## Проблемы организации программного стека

В стеке нужно следить, чтобы данные не затирали другие данные или инструкции программы.

Если стек растет в сторону больших адресов, можно выделить явно память и организовать стек в рамках выделенного участка памяти. Вы сами должны следить, чтобы не выходить за границы этого участка. Выделим память на 10 слов, начиная с адреса `B`:
```cpp
B:  .BLKW 10
```
Чуть проще организовать рост стека в сторону меньших адресов. Пусть наша программа начинается с адреса 1000, тогда организуем стек, растущий в строну меньших адресов, ровно над программой. Код программы идет вниз по адресам 1000, 1002, 1004 и так далее, данные в стеке идут вверх по адресам 776, 774, 772 и так далее.

```cpp
        .=1000
START:  mov #START, R4; R4 - указатель на вершину стека 
```
Если в стек кладутся только слова командой `mov`, или только байты командой `movb`, все хорошо. Но если в стек попытаться класть и слова, и байты вперемешку, то может оказаться такое, что положили слово по четному адресу, указатель на верхушку стека содержит четный адрес. Положили байт, указатель на верхушку стека стал содержать **нечетный** адрес и слово теперь в стек положить нельзя. 

```cpp
mov  #17, -(R4); R4 -= 2, стал равен 776, по адресу 776 записали слово 17.
movb #'z, -(R4); R4 -= 1, стал равен 775, по адресу 775 записали ascii-код символа z.
```

Надо руками добавлять "пустой байт" в стек, чтобы положить слово. При разборе стека тоже нужно помнить, что клали, чтобы пропустить "пустой байт" и не читать слово по нечетному адресу.

Любая сложность - это потенциальный источник ошибок. Для того, чтобы работал стек с разнотипными данными, сделали **аппаратный стек на регистре `R6`**. При записи и чтении слова или байта, у нас адрес изменяется всегда на 2. Этот регистр так же называют **SP (stack pointer)**. Стек называется аппаратным, потому что существуют аппаратные инструкции, которые его используют. В архитектуре мод адресации заложено, что работа с `R6` - это всегда изменение значения регистра на 2 (для мод 2 и 4).

## Что реализуем

Если вы еще не реализовали моду 6, то стоит ее реализовать. Вместе с тестами.

Желательно написать тесты для мод 2 и 4 для регистра `R6`.


 
