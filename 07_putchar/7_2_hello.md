# Hello, world!

lesson = 320749

## SKIP VIDEO 

https://youtu.be/cyintR2RSGc

## Программа "Hello, world!"

Если вы пропустили описание [псевдокоманд .ASCII и .ASCIZ](https://stepik.org/lesson/706562/step/8), то прочитайте о них.

Программа аналогична программе [суммирования массива байт, оканчивающегося нулем](https://stepik.org/lesson/320178/step/5). Там мы суммировали, тут надо выводить на экран.

```
ostat = 177564
odata = 177566

	.=200
STR:	.ASCIZ /Hello, world!/

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; R1 - адрес очередного символа
; R0 - значение ascii кода этого символа (число)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	.=1000
	mov     #STR, R1
LOOP_STR:
	movb    (R1)+, R0
	beq     END
putc:
	tstb	@#ostat
	bpl	    putc
	movb	R0, @#odata
	br LOOP_STR
END:
	halt
```
Определение констант (они не лежат ни по какому адресу, аналог #define языка Си):
```cpp
ostat = 177564
odata = 177566
```
Блок данных:
```cpp
	.=200
STR:	.ASCIZ /Hello, world!/
```
Строка расположена с адреса 200. Это байтовый массив чисел (ascii-кодов), оканчивающийся нулем.

Используются регистры:

* **R1** - адрес очередного символа,
* **R0** - ascii-код очередного символа,

Код вывода одного символа на экран, чей ascii-код лежит в `R0`.
```cpp
putc:
	tstb	@#ostat
	bpl	    putc
	movb	R0, @#odata
```
Код аналогичен суммированию массива, оканчивающегося нулем. 

`R1` указывает на начало строки. В цикле:

* Символ (его ascii-код) по адресу, записанному в `R1`, копируем в регистр `R0`, адрес увеличиваем на 1.
* Если ascii-код 0, то это признак конца строки, выходим из цикла.
* Иначе выводим символ на экран.
* Повторяем цикл.

```cpp
	.=1000
	mov     #STR, R1    ; R1 = STR
LOOP_STR:               ; while(1) {
	movb    (R1)+, R0   ;     R0 = *R1, R1++
	beq     END         ;     if (R0 == 0) goto END
    ...                 ;     вывод одного символа на экран
	br LOOP_STR         ; }
END:
	halt
```