# Регистры внешних устройств

lesson = 320747

## SKIP VIDEO Общее видео

https://youtu.be/-Z9gpZ3wXH4

## SKIP VIDEO 

https://youtu.be/5cdW0mspn_4

## План урока

1. Научиться печатать на экране один символ.
2. Написать программу, которая выводит "Hello, world!"

Для этого к CPU и RAM (памяти) нужно добавить как минимум устройство "дисплей" (или монитор) и научиться с ним работать. 

**Понятие прерываний выходит за рамки написания эмулятора**. Студенты МФТИ должны были узнать о них на лекциях по архитектуре компьютера.

## Внешние устройства

На условной схеме архитектуры Фон Неймана, общая шина данных соединяет ЦПУ, RAM (память) и внешние устройства.

![архитектура](https://stepik.org/media/attachments/lesson/320747/fon_neiman.svg)

Внешними устройствами по отношению к CPU и RAM являются:

* дисплей, клавиатура, мышь, принтер и прочие устройства ввода-вывода;
* внешняя память (жесткие диски, магнитные ленты, флешки и тп).

Взаимодействие с ними происходит через **регистры внешних устройств**. Но это не дополнительная память (как PSW), а **последние 8 кБ** RAM. То есть каждому устройству, например дисплею, соответствуют конкретные ячейки памяти с фиксированными адресами.

То есть за каждым устройством закреплен фиксированный адрес и эти адреса описаны в документации.

* Монитор:
    * 0177564 - статус и команды монитора,
    * 0177566 - данные, которые выводятся на монитор.
* Клавиатура:
    * 0177560 - статус и команды клавиатуры,
    * 0177562 - данные, которые прочитаны с клавиатуры.

Как в ассемблере работают с этими константами, чтобы выводить символы на монитор и читать их ввод с клавиатуры?

## Печать одного символа в программе 

Для того, чтобы символ был выведен на монитор, его ASCII код всего-навсего нужно поместить в байт с адресом **0177566**.

ASCII-код символа в ассемблере записывается как **одинарная кавычка** и за ней символ, например, `'a` - ASCII-код буквы `a`.

Похоже на запись символьной константы в языке Си `'a'`.

Чтобы не писать длинные константы (и не ошибаться в них), в ассемблере используют псевдокоманды, чтобы определить константы:
```cpp
ostat = 177564  ; регистр состояния дисплея дисплея
odata = 177566  ; регистр данных дисплея
```
Далее командой `movb` копируем ASCII-код по адресу 177566:
```
movb #'a, @#odata   ; 3 мода
```
или 
```
movb #'a, odata     ; 6 мода
```
Написать таким образом на экран `hello` не получится:
```
movb #'h, odata
movb #'e, odata
movb #'l, odata
movb #'l, odata
movb #'o, odata
```
Почему? Потому что вывод символа на экран - очень долгая операция по сравнению с записью в RAM и командой процессора.

Мы записываем одно значение за другим на одно место в памяти. При этом шина данных передает данные в память быстрее, чем внешнее устройство успевает отрисовать очередной символ. Символы пишутся один поверх другого и таким образом, следующий символ затирает данные предыдущего еще до того, как его начали выводить на дисплей. То есть мы требуем рисовать новый символ, когда устройство еще рисует предыдущий и **не готово к работе**.

Для этого в регистре состояния устройства по адресу 177564 в бите номер 7 пишется флаг готовности устройства. 1 - устройство готово, 0 - устройство НЕ готово.

Напишем код на ассемблере, которое будет ждать готовности устройства. 7 бит - это знаковый бит по адресу 177564. Командой `TSTB` знаковый бит занесем в флаг `N` и будем в цикле проверять значение флага, пока он не станет N=1.

```
ostat = 0177564   ; TTO command and status register for PDP-11
odata = 0177566   ; TTO data register

    . = 1000
    mov    #'*, R0     ; В R0 ascii код символа * 
putchar:
    tstb   @#ostat     ; проверяем бит 7 в ostat (это знаковый бит!!!)
    bpl    putchar     ; if ( bit 7 == 0 ) перейти на метку putchar, устройство занято
    movb   R0, @#odata ; записываем ascii код в odata (вывод на экран)
    
    halt
```
**В эталонном эмуляторе без проверки бита готовности устройства, эмулятор не выводит символы**.

В вашем эмуляторе напишите код так, чтобы ваше устройство **всегда было готово**. То есть по адресу 0177564 в 7 бите всегда должна быть 1 (что будет в других битах - на ваше усмотрение, можно все биты заполнить единицами).

## Реализация вывода на дисплей в эмуляторе

Если программа на ассемблере пишет данные по адресу 0177566, нужно выводить соответствующий данному ascii коду символ на экран.

Для этого используйте функцию `putchar` или `printf`.

Внимание! Посмотрите, как у вас задан массив `mem`. Если вы задали массив размером в 64 Кб, то все равно, записываете вы по адресу 0177564 и 0177566 или нет.

Но если вы, зная, что последние 8 Кб - регистры внешних устройств и задали массив размера 56 Кб, то при попытке записи или чтения по этим адресам происходит выход за границы массива и чтение по неинициализированным данным. Проверьте программу с valgrind. Если вы задали укороченный массив, то вам нужно **вместо** чтения и записи в массив, возвращать нужные константы (эмулировать, что устройство всегда готово) и выводить символ на экран.

